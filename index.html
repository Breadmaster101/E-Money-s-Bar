<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Money's Bar 1.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #1A222C; 
            --secondary-bg: #273440; 
            --tertiary-bg: #11171E; 
            --primary-text: #E0E6EB; 
            --secondary-text: #A0AEC0; 

            --accent-gold: #CFAF7B; 
            --accent-gold-darker: #B08F5F; 
            --accent-red: #E53E3E; 
            --accent-red-darker: #C53030; 
            --accent-green: #48BB78; 
            --accent-green-darker: #38A169; 
            --accent-highlight: #F6E05E; 

            --table-green: #2A4B3A; 
            --table-green-light: #3A6B4A; 
            
            --font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-family-serif: 'Merriweather', serif;
            --border-radius: 6px; 
            --box-shadow: 0 5px 15px rgba(0,0,0,0.35);
            --box-shadow-light: 0 3px 8px rgba(0,0,0,0.25);

            --input-bg: #D1D5DB; 
            --input-text: #1A222C; 
            --input-border: #6B7280; 

            --card-bg: #FEFDFB; 
            --card-border: #D1C7B7; 
            --card-selected-glow:  0 0 15px 4px var(--accent-gold); 
            
            --suit-red: var(--accent-red); 
            --suit-black: #2D3748; 

            --card-back-bg: #4A3B30; 
            --card-back-border: #30261F; 
            --card-back-motif: var(--accent-gold);
        }

        /* General Styles */
        body { 
            font-family: var(--font-family); 
            margin: 0; 
            padding: 0; 
            background-color: var(--tertiary-bg); 
            color: var(--primary-text); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            overflow: hidden; 
            background-image: 
                radial-gradient(circle at top left, rgba(255,255,255,0.03), transparent 40%),
                radial-gradient(circle at bottom right, rgba(255,255,255,0.03), transparent 40%);
        }
        #app-container { 
            width: 100vw; 
            height: 100vh; 
            max-width: none; 
            max-height: none; 
            border-radius: 0; 
            display: flex; 
            flex-direction: column; 
            background-color: var(--primary-bg); 
            box-shadow: none; 
            overflow: hidden; 
        }
        button { 
            padding: 12px 24px; 
            font-size: 1em; 
            font-weight: 600; 
            background-color: var(--accent-gold); 
            color: var(--primary-bg); 
            border: none; 
            border-radius: var(--border-radius); 
            cursor: pointer; 
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 -2px 0px rgba(0,0,0,0.15);
            text-transform: uppercase; 
            letter-spacing: 0.8px; 
            font-family: var(--font-family);
        }
        button:hover { 
            background-color: var(--accent-gold-darker); 
            transform: translateY(-2px); 
            box-shadow: 0 4px 8px rgba(0,0,0,0.25), inset 0 -1px 0px rgba(0,0,0,0.1); 
        }
        button:active { 
            transform: translateY(0px); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.2), inset 0 -1px 0px rgba(0,0,0,0.1); 
        }
        button:disabled { 
            background-color: #546e7a; 
            color: #90a4ae; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: inset 0 -2px 0px rgba(0,0,0,0.1); 
        }
        /* Base Textarea, Input - for non-copy-button ones */
        textarea, input[type="text"], input[type="number"], select { 
            width: calc(100% - 24px); 
            max-width: 500px; 
            margin: 10px auto; /* Centering */
            padding: 12px; 
            border-radius: var(--border-radius); 
            border: 1px solid var(--input-border); 
            background-color: var(--input-bg); 
            color: var(--input-text); 
            font-size: 1em; 
            box-sizing: border-box; 
            transition: border-color 0.2s ease, box-shadow 0.2s ease; 
            font-family: var(--font-family);
        }
        textarea { min-height: 80px; resize: vertical; }
        input:focus, textarea:focus, select:focus { 
            outline: none; 
            border-color: var(--accent-gold); 
            box-shadow: 0 0 0 3px rgba(207, 175, 123, 0.4); 
        }

        /* Modal styles */
        .modal { position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(17, 23, 30, 0.85); display: flex; justify-content: center; align-items: center; backdrop-filter: blur(6px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content { 
            background-color: var(--secondary-bg); 
            padding: 35px 40px; 
            border: 2px solid var(--accent-gold-darker); 
            width: 90%; max-width: 600px; 
            border-radius: var(--border-radius); 
            box-shadow: var(--box-shadow), 0 0 0 6px var(--primary-bg); 
            text-align: center; 
            transform: scale(0.95); 
            transition: transform 0.3s ease; 
            color: var(--primary-text);
        }
        .modal.visible .modal-content { transform: scale(1); }
        .modal-content h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            color: var(--accent-highlight); 
            font-size: 2.2em; 
            font-weight: 700; 
            font-family: var(--font-family-serif);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .modal-content button { margin: 15px 8px 0; }

        /* Connection Setup Screen */
        #connection-setup { padding: 35px; text-align: center; overflow-y: auto; height: 100%; display: flex; flex-direction: column; align-items: center; background-color: var(--primary-bg); }
        #connection-setup h2 { color: var(--primary-text); margin-bottom: 30px; font-size: 2.8em; font-weight: 700; font-family: var(--font-family-serif); text-shadow: 1px 1px 3px rgba(0,0,0,0.3); }
        /* #connection-setup > input[type="text"] - covered by general input rule for centering */
        #connection-setup > div:first-of-type { margin-bottom: 20px; } /* Button group container */
        .setup-section { background-color: var(--secondary-bg); padding: 30px; margin-top: 30px; border-radius: var(--border-radius); box-shadow: inset 0 3px 6px rgba(0,0,0,0.2), var(--box-shadow-light); width: 100%; max-width: 750px; box-sizing: border-box; border: 1px solid var(--tertiary-bg); }
        .setup-section h3 { color: var(--accent-gold); margin-top: 0; margin-bottom: 25px; font-size: 1.8em; border-bottom: 2px solid var(--accent-gold-darker); padding-bottom: 12px; font-family: var(--font-family-serif); }
        #host-controls p, #client-controls p { margin: 12px 0; font-size: 1.1em; color: var(--secondary-text); }
        #host-controls p strong, #client-controls p strong { color: var(--primary-text); }
        #connected-players-list { margin-top: 15px; font-weight: normal; text-align: left; padding-left: 10px; }
        #connected-players-list span { display: block; margin-bottom: 6px; padding: 8px 10px; background-color: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid var(--accent-gold); }
        #startGameBtn { background-color: var(--accent-green); color: white; margin-top: 25px; padding: 15px 30px; font-size: 1.2em;}
        #startGameBtn:hover { background-color: var(--accent-green-darker); }
        .connection-slot { background-color: var(--primary-bg); padding: 20px; margin: 20px auto; border-radius: var(--border-radius); border: 2px solid #4a6075; max-width: 100%; /* Host slot itself is already centered by parent's align-items or its own margin: auto */ transition: border-color 0.3s ease, background-color 0.3s ease; box-shadow: var(--box-shadow-light); }
        .connection-slot.connected { border-color: var(--accent-green) !important; background-color: var(--table-green-light) !important; }
        .connection-slot p { margin: 10px 0 8px; font-weight: 500; font-size: 1.05em; color: var(--secondary-text); }
        .connection-slot button { margin-top: 12px; font-size: 0.95em;} /* Host slot's "Process Answer" button */
        #client-status { margin-top: 20px; font-weight: bold; font-size: 1.1em; padding: 10px; border-radius: var(--border-radius); background-color: rgba(0,0,0,0.1); }
        
        /* Debug Log styles */
        #debug-log { margin-top: 35px; background: var(--tertiary-bg); padding: 18px; border-radius: var(--border-radius); max-height: 180px; overflow-y: auto; font-size: 0.9em; text-align: left; width: 100%; max-width: 750px; box-sizing: border-box; border: 1px solid #4a6075; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); margin-left: auto; margin-right: auto; /* Ensure debug log also centers */ }
        #debug-log strong { color: var(--accent-highlight); display: block; margin-bottom: 8px; font-size: 1.1em; font-family: var(--font-family-serif); }
        #debug-log p { margin: 3px 0; line-height: 1.5; color: var(--secondary-text); }
        #debug-log p:nth-child(odd) { background-color: rgba(255,255,255,0.03); }


        /* STYLES FOR TEXTAREA WITH INTERNAL BUTTON */
        .textarea-container-visual {
            position: relative;
            display: block; 
            box-sizing: border-box;
            border-radius: var(--border-radius);
            
            width: 100%; /* Takes full width of its parent slot within setup-section */
            max-width: 500px; /* But not more than 500px */
            margin: 10px auto; /* Centering for the visual container */
        }
        
        #client-controls .textarea-container-visual {
             background-color: var(--input-bg);
             border: 1px solid var(--input-border);
             min-height: 80px; 
             margin-bottom: 15px; 
        }

        .connection-slot .textarea-container-visual { /* For host offers */
            background-color: var(--tertiary-bg);
            border: 1px solid #4a6075; 
            /* width: 100%; is inherited */
            /* max-width: 500px; is inherited */
            /* margin: 10px auto; is inherited */
            margin-bottom: 10px; 
            min-height: 65px; 
        }
        
        .textarea-container-visual > textarea {
            width: 100%;
            height: 100%; 
            min-height: calc(100% - 2px); 
            box-sizing: border-box;
            border: none;
            background: transparent;
            outline: none;
            box-shadow: none;
            resize: vertical;
            font-family: var(--font-family);
            padding: 10px 45px 10px 10px; /* Top, Right (for button), Bottom, Left */
        }

        #client-controls .textarea-container-visual > textarea {
            color: var(--input-text);
            font-size: 1em;
        }
        
        .connection-slot .textarea-container-visual > textarea {
            color: var(--primary-text);
            font-size: 0.9em;
        }

        .textarea-container-visual > .copy-btn-internal {
            position: absolute;
            top: 6px;      
            right: 6px;     
            padding: 4px 8px; 
            font-size: 0.8em; 
            background-color: #4A5568; 
            color: var(--primary-text); 
            border: 1px solid #2D3748; 
            border-radius: 4px; 
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            z-index: 5; 
            line-height: 1; 
        }
        .textarea-container-visual > .copy-btn-internal:hover {
            background-color: #2D3748; 
            color: var(--accent-gold); 
            border-color: var(--accent-gold-darker);
        }
        .textarea-container-visual > .copy-btn-internal:disabled { 
            background-color: var(--accent-green-darker);
            color: white;
            cursor: default;
            border-color: var(--accent-green); 
        }


        /* Game Board */
        #game-board { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            background-color: var(--table-green); 
            background-image: 
                radial-gradient(ellipse at center, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.0) 70%),
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.07'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); 
            position: relative; 
            overflow: hidden; 
            padding: 20px; 
            box-sizing: border-box; 
        }
        #player-areas-container { 
            position: relative; 
            flex-grow: 1;      
            width: 100%;      
            height: 100%;     
        }
        .player-area { 
            position: absolute; 
            background-color: rgba(26, 34, 44, 0.85); 
            padding: 10px 15px; 
            border-radius: var(--border-radius); 
            text-align: center; 
            min-width: 170px; 
            max-width: 200px; 
            box-shadow: var(--box-shadow), 0 0 0 2px rgba(0,0,0,0.2); 
            border: 2px solid var(--tertiary-bg); 
            transition: transform 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease, opacity 0.4s ease; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            transform-origin: center center;
            box-sizing: border-box; 
        }
        .player-area.current-player { 
            border-color: var(--accent-highlight); 
            z-index: 10; 
            animation: pulsePlayer 1.8s infinite ease-in-out; 
        }
        @keyframes pulsePlayer { 
            0% { 
                box-shadow: 0 0 25px 0px var(--accent-highlight), 0 0 35px 6px rgba(246, 224, 94, 0.55), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.03); 
            } 
            50% { 
                box-shadow: 0 0 30px 4px var(--accent-highlight), 0 0 45px 10px rgba(246, 224, 94, 0.65), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.05); 
            } 
            100% { 
                box-shadow: 0 0 25px 0px var(--accent-highlight), 0 0 35px 6px rgba(246, 224, 94, 0.55), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.03); 
            } 
        }

        .player-area.eliminated { opacity: 0.5; filter: grayscale(100%); border-color: var(--secondary-text) !important; box-shadow: none !important; animation: none !important; transform: scale(0.95) translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)); }
        .player-name { font-weight: bold; font-size: 1.1em; margin-bottom: 4px; color: var(--primary-text); line-height: 1.2; font-family: var(--font-family-serif); }
        .player-avatar { font-size: 2.1em; margin-bottom: 5px; line-height: 1; color: var(--accent-gold); }

        .player-card-visuals {
            position: relative; 
            height: 40px; 
            width: 80px; 
            margin: 2px auto 3px;
            display: flex;
            justify-content: center;
            align-items: flex-end; 
        }
        .player-area-mini-card { 
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4));
        }
        .player-area-mini-card svg { 
            width: 22px !important; 
            height: 33px !important; 
        }
        .player-area-mini-card svg rect[stroke="var(--card-back-border)"] { stroke-width: 0.5px; }
        .player-area-mini-card svg rect[x="3.5"] { display: none; } 
        .player-area-mini-card svg text { font-size: 16px !important; }

        .player-revolver-visuals {
            position: relative; 
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 4px;
            gap: 3px;
        }
        .revolver-chamber {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            border: 1px solid var(--accent-gold-darker);
            transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
        }
        .revolver-chamber.available {
            background-color: var(--accent-gold); 
        }
        .revolver-chamber.fired {
            background-color: var(--tertiary-bg); 
            opacity: 0.6;
        }
        
        .has-tooltip {
            cursor: default; 
        }
        .has-tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%; 
            left: 50%;
            transform: translateX(-50%) translateY(-5px); 
            background-color: var(--tertiary-bg);
            color: var(--primary-text);
            padding: 4px 7px; 
            border-radius: 4px;
            font-size: 0.7em; 
            font-family: var(--font-family);
            white-space: nowrap; 
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease 0.1s, visibility 0s linear 0.3s; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: none; 
        }
        .has-tooltip:hover::after {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.2s ease 0.1s;
        }

        #local-player-stats-area {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(26, 34, 44, 0.75);
            padding: 8px 12px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-light);
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }
        #local-player-stats-area .stat-label {
            font-size: 0.8em;
            color: var(--secondary-text);
            margin-bottom: 2px;
        }
        #local-player-stats-area .player-revolver-visuals {
            margin-top: 0; 
        }


        #center-table { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            display: flex; flex-direction: column; align-items: center; 
            padding: 20px; 
            background-color: rgba(17, 23, 30, 0.6); 
            border: 2px solid rgba(0,0,0,0.3); 
            border-radius: 12px; 
            min-width: 320px; 
            box-shadow: var(--box-shadow), inset 0 0 15px rgba(0,0,0,0.3); 
        }
        #center-pile-visual { width: 75px; height: 105px; margin-bottom: 12px; position: relative; }
        #center-pile-visual .card-stack { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #center-pile-visual .card-back-dummy { 
            position: absolute; 
            border-radius: 6px; 
            width: 60px; height: 90px; 
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }

        #table-type-display-area { margin-bottom: 10px; text-align: center; } 
        #table-type-display-area h4 { margin: 0 0 8px 0; font-size: 1em; color: var(--secondary-text); font-weight: 500; letter-spacing: 0.5px; }
        #table-type-card { 
            display: inline-flex; justify-content: center; align-items: center; 
            width: 60px; height: 90px; 
            background-color: var(--card-bg); 
            border: 1px solid var(--card-border); 
            border-radius: 6px; font-size: 48px; line-height: 1; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 0 5px rgba(0,0,0,0.1);
            color: var(--primary-text); 
        }
        #played-cards-pile-info { 
            font-size: 1em; font-weight: bold; margin-bottom: 10px; 
            padding: 10px 15px; 
            background-color: rgba(0,0,0,0.25); 
            border-radius: var(--border-radius); 
            min-height: 22px; text-align: center; 
            color: var(--primary-text); 
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }

        #game-log { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 280px; max-width: 30%; max-height: 180px; z-index: 30; 
            background-color: rgba(210, 199, 183, 0.9); 
            color: #3A322E; 
            border-radius: var(--border-radius); 
            padding: 10px 15px; 
            border: 2px solid #A1887F; 
            box-shadow: var(--box-shadow-light); 
            font-family: var(--font-family-serif);
        }
        #game-log h4 { 
            margin: 0 0 8px 0; text-align: center; font-size: 1.05em; 
            color: #5D4037; 
            border-bottom: 1px solid #A1887F; 
            padding-bottom: 6px; font-weight: 700; 
        }
        #log-messages { 
            height: 110px; overflow-y: auto; font-size: 0.85em; 
            padding: 8px; border-radius: 4px; 
            background-color: rgba(0,0,0,0.05); 
            color: #4E342E;
        }
        #log-messages p { margin: 4px 0; line-height: 1.4; }
        #log-messages p.error { color: var(--accent-red-darker); font-weight: bold; }
        #log-messages p.system { color: #00695C; font-style: italic; } 
        #log-messages p.success { color: var(--accent-green-darker); font-weight: bold; }
        #log-messages::-webkit-scrollbar { width: 8px; } 
        #log-messages::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; } 
        #log-messages::-webkit-scrollbar-thumb { background: #8D6E63; border-radius: 4px; } 
        #log-messages::-webkit-scrollbar-thumb:hover { background: #795548; }

        #player-hand-area { 
            position: absolute; bottom: 20px; left: 50%; 
            transform: translateX(-50%); 
            display: flex; gap: 8px; 
            padding: 10px; 
            background-color: rgba(17, 23, 30, 0.5); 
            border-radius: var(--border-radius); 
            z-index: 20; 
            box-shadow: var(--box-shadow), 0 0 0 2px rgba(0,0,0,0.15); 
            transition: box-shadow 0.3s ease, border-color 0.3s ease; 
            border-top: 2px solid rgba(255,255,255,0.05);
        }
        #player-hand-area.current-player-hand { 
            border-top-color: var(--accent-highlight);
            box-shadow: 
                0 0 20px 5px var(--accent-highlight), 
                inset 0 -2px 0 0 var(--accent-highlight), 
                inset -2px 0 0 0 var(--accent-highlight), 
                inset 2px 0 0 0 var(--accent-highlight),  
                0 0 0 2px rgba(0,0,0,0.15); 
        }
        #player-hand-area.card-selection-active { 
            border-top-color: var(--accent-gold);
            box-shadow: 
                0 0 18px 6px var(--accent-gold), 
                inset 0 -2px 0 0 var(--accent-gold), 
                inset -2px 0 0 0 var(--accent-gold), 
                inset 2px 0 0 0 var(--accent-gold), 
                0 0 0 2px rgba(0,0,0,0.15); 
        } 
        #player-hand-area.card-selection-active .card-container { cursor: pointer; opacity: 0.75; filter: saturate(0.7); }
        #player-hand-area.card-selection-active .card-container.selected-for-play { opacity: 1; transform: translateY(-18px) scale(1.12); filter: saturate(1); }
        #player-hand-area.card-selection-active .card-container.selected-for-play svg { box-shadow: var(--card-selected-glow); }

        .card-container { display: inline-block; perspective: 1000px; transition: opacity 0.2s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .card-container svg { display: block; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); border-radius: 6px; }
        
        #player-hand-area > .card-container:not(.selected-for-play):hover svg { 
            transform: translateY(-18px) scale(1.12) rotateX(8deg); 
            box-shadow: 0 10px 20px rgba(0,0,0,0.25); 
        }
        #player-hand-area > .card-container.selected-for-play svg { 
            transform: translateY(-12px) scale(1.08); 
            box-shadow: var(--card-selected-glow); 
        }


        #play-confirm-area { 
            position: absolute; bottom: 110px; 
            left: 50%; transform: translateX(-50%); 
            padding: 12px 18px; 
            background-color: rgba(39, 52, 64, 0.95); 
            border-radius: var(--border-radius); 
            box-shadow: var(--box-shadow); 
            z-index: 22; text-align: center; 
            border: 1px solid var(--tertiary-bg);
        }
        #play-confirm-area p { margin:0 0 12px 0; font-size: 0.95em; color: var(--primary-text); }
        #actions-area { 
            position: absolute; bottom: 25px; right: 25px; 
            display: flex; flex-direction: column; gap: 12px; z-index: 25; 
        }
        #actions-area button { 
            width: 170px; padding: 14px 18px; font-size: 1em; letter-spacing: 0.6px;
        }
        #playCardsBtn { background-color: var(--accent-green); color: white; } 
        #playCardsBtn:hover { background-color: var(--accent-green-darker); }
        #callLiarBtn { background-color: var(--accent-red); color: white; } 
        #callLiarBtn:hover { background-color: var(--accent-red-darker); }
        #confirmPlayBtn { background-color: var(--accent-green); color: white; }
        #cancelPlayBtn { background-color: var(--secondary-text); color: var(--primary-bg); }
        #cancelPlayBtn:hover { background-color: #BCC1C6; }


        #challenge-roulette-overlay .modal-content { max-width: 700px; padding: 40px; }
        #challenge-roulette-overlay #revealed-cards-display { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0; padding: 12px; background-color: rgba(0,0,0,0.2); border-radius: var(--border-radius); border: 1px solid rgba(0,0,0,0.1); }
        #challenge-roulette-overlay #roulette-result-text { font-weight:bold; font-size: 1.4em; margin: 20px 0; letter-spacing: 0.5px; }
        #challenge-roulette-overlay #roulette-animation { font-size: 2.2em; margin: 15px; min-height: 50px; display: flex; justify-content: center; align-items: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        #roulette-animation.spinning span { display: inline-block; animation: spin 0.5s linear infinite, symbolPulse 0.25s alternate infinite ease-in-out; }
        @keyframes spin { 0% { transform: rotate(0deg) scale(1); } 100% { transform: rotate(360deg) scale(1); } }
        @keyframes symbolPulse { 0% { transform: scale(0.9); opacity: 0.8; } 100% { transform: scale(1.1); opacity: 1;} }
        
        #game-over-overlay .modal-content { max-width: 520px; }
        #gameOverTitle { color: var(--accent-highlight); font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.4); }
        #gameOverMessageP { font-size: 1.25em; margin-bottom: 20px; line-height: 1.5; } 
        #rematch-status-container { margin-top: 15px; text-align: left; font-size: 0.9em;}
        #rematch-status-container h4 { margin-bottom: 8px; color: var(--accent-gold); font-size: 1.1em; }
        #rematch-status-list span { display: block; margin-bottom: 4px; padding: 3px 6px; background-color: rgba(255,255,255,0.03); border-radius: 3px;}
        #rematch-status-list .ready { color: var(--accent-green); font-weight: bold; }
        #rematch-status-list .not-ready { color: var(--secondary-text); }

        #playAgainBtn { background-color: var(--accent-gold); color: var(--primary-bg); } 
        #playAgainBtn:hover { background-color: var(--accent-gold-darker); }
        #exitGameBtn { background-color: var(--secondary-text); color: var(--primary-bg); } 
        #exitGameBtn:hover { background-color: #95a5a6; }

        /* Responsive Adjustments */
        @media (max-width: 1200px) { 
            .player-area { min-width: 160px; padding: 10px 15px;} 
            #game-log { width: 240px; max-height: 160px; } 
            #local-player-stats-area { top: 15px; left: 15px; padding: 6px 10px;}
        }
        @media (max-width: 768px) { 
            body { font-size: 14px; } 
            .player-area { padding: 8px 10px; min-width: 110px !important; width: auto !important; } 
            .player-area .player-name { font-size: 0.8em; } 
            .player-area .player-avatar { font-size: 1.5em; margin-bottom: 4px;} 
            #center-table { min-width: 80%; padding: 12px; } 
            #center-pile-visual { width: 55px; height: 80px; margin-bottom: 6px;} 
            #center-pile-visual .card-back-dummy { width: 50px; height: 75px; }
            #table-type-display-area { margin-bottom: 8px;} 
            #table-type-card { font-size: 32px; width: 50px; height:75px; } 
            #played-cards-pile-info { font-size: 0.85em; padding: 8px 10px;} 
            #game-log { bottom: auto; top: 100px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 300px; max-height: 70px; padding: 8px; font-size: 0.9em; } 
            #log-messages { height: 35px; font-size: 0.78em; } 
            #player-hand-area { bottom: 85px; max-width: 95%; gap: 4px; padding: 8px; } 
            .card-container svg { width: 45px; height: 68px;} 
            #play-confirm-area { bottom: 165px; width: 90%; padding: 10px;} 
            #actions-area { flex-direction: row; bottom: 15px; left: 50%; transform: translateX(-50%); width: 95%; justify-content: space-around; gap: 8px; } 
            #actions-area button { width: auto; flex-grow: 1; padding: 12px 10px; font-size: 0.9em; } 
            
            .player-card-visuals { height: 35px; width: 60px; } 
            .player-area-mini-card svg { width: 20px !important; height: 30px !important; }
            .revolver-chamber { width: 8px !important; height: 8px !important; }
            #local-player-stats-area { top: 10px; left: 10px; padding: 5px 8px; gap: 3px;}
            #local-player-stats-area .stat-label { font-size: 0.7em; }
            #game-log { top: 65px; max-height: 60px; } 
            #log-messages { height: 25px; }
        }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="connection-setup">
            <h2>E-Money's Bar 1.1</h2>
            <input type="text" id="playerNameInput" placeholder="Enter Your Name (Min 3 chars)" value="">
            <div>
                <button id="createRoomBtn">Create Room</button>
                <button id="joinRoomBtn">Join Room</button>
            </div>
            <div id="host-controls" class="setup-section" style="display:none;">
                <h3>Host Controls</h3>
                <p>Share your Host Offers with joining players one by one. Paste their Answers back.</p>
                <div id="host-connection-slots"></div>
                <p><strong>Connected Players:</strong> <span id="connected-players-count">0</span></p>
                <div id="connected-players-list"></div>
                <button id="startGameBtn" disabled>Start Game (2-4 Players)</button>
            </div>
            <div id="client-controls" class="setup-section" style="display:none;">
                <h3>Join Room</h3>
                <p><strong>1. Paste Host's Offer for you:</strong></p>
                <textarea id="hostOfferInput" placeholder="Paste Host's Offer SDP here"></textarea>
                <p><strong>2. Click to generate your Answer:</strong></p>
                <button id="generateAnswerBtn">Generate Answer</button>
                <p><strong>3. Copy your Answer and give it to the Host:</strong></p>
                <div class="textarea-container-visual"> 
                    <textarea id="clientAnswerOutput" readonly placeholder="Your Answer SDP will appear here"></textarea>
                    <button id="copyClientAnswerBtn" class="copy-btn-internal" type="button" title="Copy Answer">COPY</button>
                </div>
                <p id="client-status"></p>
            </div>
             <div id="debug-log"><strong>Debug Log:</strong></div>
        </div>

        <div id="game-board" style="display:none;">
            <div id="local-player-stats-area" style="display:none;">
                <span class="stat-label">My Revolver:</span>
                <div id="local-revolver-visuals" class="player-revolver-visuals has-tooltip"></div>
            </div>
            <div id="player-areas-container"></div>
            <div id="center-table">
                <div id="center-pile-visual"><div class="card-stack"></div></div>
                <div id="table-type-display-area">
                    <h4>Table Suit:</h4>
                    <div id="table-type-card"></div> 
                </div>
                <div id="played-cards-pile-info">Played this turn: 0 cards</div>
            </div>
            <div id="game-log"><h4>Game Log</h4><div id="log-messages"></div></div>
            <div id="play-confirm-area" style="display:none;">
                <p id="play-confirm-text">Play 0 cards as X?</p>
                <button id="confirmPlayBtn">Confirm</button>
                <button id="cancelPlayBtn">Cancel</button>
            </div>
            <div id="player-hand-area"></div>
            <div id="actions-area">
                <button id="playCardsBtn" disabled>Play Cards</button>
                <button id="callLiarBtn" disabled>"LIAR!"</button>
            </div>
        </div>

        <div id="challenge-roulette-overlay" class="modal">
            <div class="modal-content">
                <h3 id="challenge-roulette-title">Challenge Result!</h3>
                <p id="challenge-roulette-details"></p> 
                <div id="revealed-cards-display"></div>
                <p id="challenge-roulette-consequence"></p> 
                <div id="roulette-animation"></div> 
                <p id="roulette-result-text"></p> 
                <button id="continueGameBtn">Continue</button>
            </div>
        </div>

        <div id="game-over-overlay" class="modal">
            <div class="modal-content">
                <h3 id="gameOverTitle">Game Over!</h3>
                <p id="gameOverMessageP"></p>
                <div id="rematch-status-container" style="display:none;">
                    <h4>Rematch Status:</h4>
                    <div id="rematch-status-list"></div>
                </div>
                <div>
                    <button id="playAgainBtn">Ready for Rematch</button>
                    <button id="exitGameBtn">Exit to Setup</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const MAX_PLAYERS = 4;
        const MIN_PLAYERS = 2;
        const HAND_SIZE = 5; 
        
        const SUITS = ['H', 'D', 'C', 'S']; 
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const SUIT_SYMBOLS = {'H': '♥', 'D': '♦', 'C': '♣', 'S': '♠'};
        const SUIT_COLORS = {'H': 'var(--suit-red)', 'D': 'var(--suit-red)', 'C': 'var(--suit-black)', 'S': 'var(--suit-black)'};

        const REVOLVER_CHAMBERS = 6;
        const REVOLVER_BULLETS = 1;

        const $ = (s) => document.querySelector(s);
        const appContainer = $('#app-container'); const connectionSetupDiv = $('#connection-setup'); const gameBoardDiv = $('#game-board');
        const playerNameInput = $('#playerNameInput'); const createRoomBtn = $('#createRoomBtn'); const joinRoomBtn = $('#joinRoomBtn');
        const hostControlsDiv = $('#host-controls');  const hostConnectionSlotsDiv = $('#host-connection-slots');
        const connectedPlayersCountSpan = $('#connected-players-count'); const connectedPlayersListDiv = $('#connected-players-list'); const startGameBtn = $('#startGameBtn');
        const clientControlsDiv = $('#client-controls'); const hostOfferInput = $('#hostOfferInput');
        const generateAnswerBtn = $('#generateAnswerBtn'); const clientAnswerOutput = $('#clientAnswerOutput'); const clientStatusP = $('#client-status');
        const debugLogDiv = $('#debug-log');
        const playerAreasContainer = $('#player-areas-container');
        const centerPileVisualStack = $('#center-pile-visual .card-stack');
        const tableTypeCardDiv = $('#table-type-card'); 
        const playedCardsPileInfo = $('#played-cards-pile-info');
        const logMessagesDiv = $('#log-messages');
        const localPlayerStatsArea = $('#local-player-stats-area');
        const localRevolverVisuals = $('#local-revolver-visuals');
        const playerHandArea = $('#player-hand-area');
        const playConfirmArea = $('#play-confirm-area');
        const playConfirmText = $('#play-confirm-text');
        const confirmPlayBtn = $('#confirmPlayBtn');
        const cancelPlayBtn = $('#cancelPlayBtn');
        const playCardsBtn = $('#playCardsBtn'); 
        const callLiarBtn = $('#callLiarBtn');   
        const challengeRouletteOverlay = $('#challenge-roulette-overlay');
        const challengeRouletteTitle = $('#challenge-roulette-title');
        const challengeRouletteDetailsP = $('#challenge-roulette-details');
        const revealedCardsDisplay = $('#revealed-cards-display'); 
        const challengeRouletteConsequenceP = $('#challenge-roulette-consequence');
        const rouletteAnimationDiv = $('#roulette-animation');
        const rouletteResultTextP = $('#roulette-result-text');
        const continueGameBtn = $('#continueGameBtn'); 
        const gameOverOverlay = $('#game-over-overlay');
        const gameOverTitle = $('#gameOverTitle'); const gameOverMessageP = $('#gameOverMessageP');
        const rematchStatusContainer = $('#rematch-status-container');
        const rematchStatusListDiv = $('#rematch-status-list');
        const playAgainBtn = $('#playAgainBtn'); const exitGameBtn = $('#exitGameBtn');
        
        let localPlayer = { id: null, name: "", isHost: false, hand: [], eliminated: false, revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0, readyForRematch: false };
        let gameState = { players: [], liarsDeck: [], tableDeck: [], centerPile: [], currentPlayerId: null, currentTableSuit: null, lastPlayedTurn: null, gamePhase: 'lobby', roomName: null, config: { handSize: HAND_SIZE }, centerPileCardCount: 0, rematchReadyStatus: {} };
        const STUN_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        let peerConnections = {}; let clientToServerPc = null; let dataChannels = {}; let clientToServerDc = null; let hostOfferInputs = {};
        let selectedCardsForPlayUI = []; 
        let lastLoggedGameStateForClient = {}; 
        let rouletteSymbolInterval = null;

        function copyToClipboard(text, buttonElement) {
            if (!text || text.trim() === "" || text.startsWith("Generating...") || text.startsWith("Error")) {
                alert("No valid content to copy yet.");
                return;
            }
            if (!navigator.clipboard) {
                // Fallback for older browsers
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed"; 
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    if (buttonElement) {
                        const originalText = buttonElement.textContent;
                        buttonElement.textContent = 'Copied!';
                        buttonElement.disabled = true;
                        setTimeout(() => {
                            buttonElement.textContent = originalText;
                            buttonElement.disabled = false;
                        }, 1500);
                    }
                    logDebug('Content copied to clipboard (fallback).');
                } catch (err) {
                    logDebug('Fallback: Oops, unable to copy', err);
                    alert('Failed to copy text using fallback.');
                }
                document.body.removeChild(textArea);
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                if (buttonElement) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'Copied!';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.disabled = false;
                    }, 1500);
                }
                logDebug('Content copied to clipboard.');
            }).catch(err => {
                logDebug('Could not copy text: ', err);
                alert('Failed to copy text.');
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function toggleModal(modalElement, show) { if (show) { modalElement.style.display = 'flex'; setTimeout(() => modalElement.classList.add('visible'), 10); } else { modalElement.classList.remove('visible'); setTimeout(() => modalElement.style.display = 'none', 300);}}
        function generateId(prefix = '') { return prefix + Math.random().toString(36).substr(2, 9); }
        function logDebug(message) { console.log(message); const p = document.createElement('p'); p.textContent = `[${new Date().toLocaleTimeString()}] ${typeof message === 'object' ? JSON.stringify(message) : message}`; debugLogDiv.appendChild(p); debugLogDiv.scrollTop = debugLogDiv.scrollHeight; }
        
        function addLogMessage(message, type = "info") { 
            const p = document.createElement('p'); 
            p.textContent = message; 
            if (type === "error") p.classList.add('error');
            else if (type === "system") p.classList.add('system');
            else if (type === "success") p.classList.add('success');
            
            if (logMessagesDiv) { 
                logMessagesDiv.appendChild(p); 
                logMessagesDiv.scrollTop = logMessagesDiv.scrollHeight; 
            } else console.warn("Log div not ready:", message); 
        }


        function createCardElement(rank, suit, faceUp = true, isSmall = false) {
            const cc = document.createElement('div'); cc.className = 'card-container'; const cardId = `${rank}${suit}`;
            const w = isSmall ? (window.innerWidth <= 768 ? 45 : 50) : 60;
            const h = isSmall ? (window.innerWidth <= 768 ? 68 : 75) : 90;
            let svg;
            if (!faceUp) { 
                svg = `<svg width="${w}" height="${h}" viewBox="0 0 60 90" class="card back" preserveAspectRatio="xMidYMid meet">
                    <rect x="0.5" y="0.5" width="59" height="89" rx="5.5" ry="5.5" fill="var(--card-back-bg)" stroke="var(--card-back-border)" stroke-width="1"/>
                    <rect x="3.5" y="3.5" width="53" height="83" rx="2.5" ry="2.5" fill="none" stroke="var(--card-back-motif)" stroke-width="1.5" opacity="0.7"/>
                    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--card-back-motif)" font-size="40" font-family="'Merriweather', serif" font-weight="bold" opacity="0.85">L</text>
                </svg>`;
            } 
            else { const rankDisplay = rank === '10' ? '10' : rank.charAt(0); const suitSymbol = SUIT_SYMBOLS[suit] || suit; const color = SUIT_COLORS[suit] || 'var(--primary-text)';
                svg = `<svg width="${w}" height="${h}" viewBox="0 0 60 90" class="card" preserveAspectRatio="xMidYMid meet">
                    <defs><filter id="cardDropShadowInternal_${cardId.replace(/[^a-zA-Z0-9]/g, '')}" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur in="SourceAlpha" stdDeviation="0.5"/><feOffset dx="0.5" dy="0.5" result="offsetblur"/><feFlood flood-color="rgba(0,0,0,0.15)"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>
                    <rect x="0.5" y="0.5" width="59" height="89" rx="5.5" ry="5.5" fill="var(--card-bg)" stroke="var(--card-border)" stroke-width="1" filter="url(#cardDropShadowInternal_${cardId.replace(/[^a-zA-Z0-9]/g, '')})"/>
                    <text x="7" y="17" font-family="var(--font-family)" font-size="${rank === '10' ? '12' : '14'}" font-weight="700" fill="${color}">${rankDisplay}</text>
                    <text x="7" y="31" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="11" fill="${color}">${suitSymbol}</text>
                    <text x="50%" y="58%" dominant-baseline="middle" text-anchor="middle" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="36" fill="${color}">${suitSymbol}</text>
                    <g transform="rotate(180 30 45)"><text x="7" y="17" font-family="var(--font-family)" font-size="${rank === '10' ? '12' : '14'}" font-weight="700" fill="${color}">${rankDisplay}</text><text x="7" y="31" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="11" fill="${color}">${suitSymbol}</text></g>
                </svg>`;}
            cc.innerHTML = svg; cc.dataset.cardId = cardId; cc.dataset.rank = rank; cc.dataset.suit = suit; return cc;
        }

        function renderPlayerHand() { playerHandArea.innerHTML = ''; localPlayer.hand.sort((a, b) => { const sO={'H':0,'D':1,'C':2,'S':3}; if(sO[a.suit]!==sO[b.suit])return sO[a.suit]-sO[b.suit]; const rV=r=>RANKS.indexOf(r); return rV(a.rank)-rV(b.rank);}).forEach(card => { playerHandArea.appendChild(createCardElement(card.rank, card.suit, true)); });}
        
        function renderPlayerAreas() {
            playerAreasContainer.innerHTML = '';
            const orderedPlayers = [...gameState.players];
            if (orderedPlayers.length === 0) return;

            const localPIndexInOrdered = orderedPlayers.findIndex(p => p.id === localPlayer.id);
            let viewPlayers = [...orderedPlayers];
            if (localPIndexInOrdered !== -1) {
                viewPlayers = [...orderedPlayers.slice(localPIndexInOrdered), ...orderedPlayers.slice(0, localPIndexInOrdered)];
            } else if (gameState.gamePhase !== 'lobby') {
                logDebug("CRITICAL: Local player not found for layout."); return;
            }

            const opponents = viewPlayers.filter(p => p.id !== localPlayer.id);
            const numOpponents = opponents.length;

            if (numOpponents === 0) return;

            const gameBoardPadding = parseFloat(getComputedStyle(gameBoardDiv).paddingTop) || 20; 
            let playerAreaWidthEstimate = 200; 
            let playerAreaHeightEstimate = 140; 

            const tempPlayerAreaForEstimates = document.createElement('div');
            tempPlayerAreaForEstimates.className = 'player-area';
            tempPlayerAreaForEstimates.style.visibility = 'hidden';
            tempPlayerAreaForEstimates.style.position = 'absolute'; 
            playerAreasContainer.appendChild(tempPlayerAreaForEstimates);
            playerAreaWidthEstimate = tempPlayerAreaForEstimates.offsetWidth || 200;
            playerAreaHeightEstimate = tempPlayerAreaForEstimates.offsetHeight || 140;
            playerAreasContainer.removeChild(tempPlayerAreaForEstimates);


            const centerTableEl = $('#center-table');
            if (!gameBoardDiv || !centerTableEl) {
                logDebug("Board or center table not found for dynamic positioning - using fallback.");
                const fallbackPositions = window.innerWidth <= 768 ? 
                    [ { top: '4%', left: '50%', translateX: '-50%', translateY: '-50%'}, { top: '30%', left: '10%', translateX: '0%', translateY: '-50%'}, { top: '30%', right: '10%', translateX: '0%', translateY: '-50%'} ] : // Adjusted top player fallback
                    [ { top: '4%', left: '50%', translateX: '-50%', translateY: '-50%'}, { top: '50%', left: '15%', translateX: '0%', translateY: '-50%'}, { top: '50%', right: '15%', translateX: '0%', translateY: '-50%'} ]; // Adjusted top player fallback
                
                opponents.forEach((opponent, idx) => {
                    const pa = document.createElement('div');
                    pa.className = 'player-area';
                    pa.dataset.playerId = opponent.id;
                    let layoutData = fallbackPositions[idx % fallbackPositions.length] || { top: `${10 + idx * 15}%`, left: '10%'};
                    Object.assign(pa.style, layoutData);
                    pa.innerHTML = `<div class="player-avatar">${opponent.isHost ? '👑' : '👤'}</div><div class="player-name">${opponent.name}</div><span>Cards: ${opponent.cardCount}, Revolver: ${opponent.revolverChambersLeft}/${REVOLVER_CHAMBERS}</span>`;
                    playerAreasContainer.appendChild(pa);
                });
                return;
            }

            const gbRect = gameBoardDiv.getBoundingClientRect();
            const ctRect = centerTableEl.getBoundingClientRect();
            
            // Y=0 for player-areas-container content (top of game board padding)
            const containerContentTopYAbsolute = gbRect.top + gameBoardPadding; 
            const containerContentLeftXAbsolute = gbRect.left + gameBoardPadding;

            // Top of the zone is the top of the game board's content area
            const zoneTopAbsoluteY = containerContentTopYAbsolute;
            // Bottom of the zone is the top of the center table
            const zoneBottomAbsoluteY = ctRect.top;
            const verticalZoneHeight = zoneBottomAbsoluteY - zoneTopAbsoluteY;

            let topPlayerCenterCssTopVal; // This will be the CSS 'top' (for the center of the PA) relative to player-areas-container's padded edge
            const MIN_TOP_EDGE_GAP = 15; // Minimum gap from the top content edge to the player area's top edge.

            // Ideal Y-coordinate for the center of the top player area, relative to the start of the vertical zone.
            // This aims to place the center of the player area at the center of the verticalZoneHeight.
            const idealCenterInZoneRelative = verticalZoneHeight / 2;

            // Ensure the top edge of the player area maintains MIN_TOP_EDGE_GAP
            // minCenterRequired is the 'top' value needed if the player area's top edge is at MIN_TOP_EDGE_GAP
            const minCenterRequired = MIN_TOP_EDGE_GAP + (playerAreaHeightEstimate / 2);

            if (verticalZoneHeight < (playerAreaHeightEstimate + 2 * MIN_TOP_EDGE_GAP) ) {
                // Not enough space to center ideally while maintaining min gaps.
                // Prioritize the MIN_TOP_EDGE_GAP.
                topPlayerCenterCssTopVal = minCenterRequired;
            } else {
                // Enough space, use the ideal centering.
                topPlayerCenterCssTopVal = idealCenterInZoneRelative;
                 // Double check it's not less than minCenterRequired (it shouldn't be if logic above is correct)
                topPlayerCenterCssTopVal = Math.max(minCenterRequired, topPlayerCenterCssTopVal);
            }
            
            // For side players, their horizontal gap from the table should be consistent.
            // Calculate the actual gap achieved above the top player.
            const actualTopGap = topPlayerCenterCssTopVal - (playerAreaHeightEstimate / 2);
            const MIN_SIDE_GAP = 20; // Minimum horizontal gap for side players.
            let sidePlayerHorizontalGap = Math.max(MIN_SIDE_GAP, actualTopGap);
            
            const ctLeftRel = ctRect.left - containerContentLeftXAbsolute;
            const ctRightRel = ctRect.right - containerContentLeftXAbsolute; 

            const layoutSlots = [];

            if (numOpponents === 1) { 
                layoutSlots.push({
                    top: `${topPlayerCenterCssTopVal}px`, left: '50%',
                    translateX: '-50%', translateY: '-50%', 
                    rotate: '0deg'
                });
            } else if (numOpponents === 2) { 
                layoutSlots.push({ // Top player
                    top: `${topPlayerCenterCssTopVal}px`, left: '50%',
                    translateX: '-50%', translateY: '-50%', 
                    rotate: '0deg'
                });
                layoutSlots.push({ // Left side player
                    top: `50%`, 
                    left: `${ctLeftRel - sidePlayerHorizontalGap - playerAreaWidthEstimate}px`,
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
            } else if (numOpponents === 3) { 
                 layoutSlots.push({ // Left side player
                    top: `50%`,
                    left: `${ctLeftRel - sidePlayerHorizontalGap - playerAreaWidthEstimate}px`,
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
                layoutSlots.push({ // Top player
                    top: `${topPlayerCenterCssTopVal}px`, left: '50%',
                    translateX: '-50%', translateY: '-50%', 
                    rotate: '0deg'
                });
                layoutSlots.push({ // Right side player
                    top: `50%`,
                    left: `${ctRightRel + sidePlayerHorizontalGap}px`, 
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
            }
            
            opponents.forEach((opponent, idx) => {
                if (idx >= layoutSlots.length) {
                    logDebug(`No dynamic layout slot for opponent index ${idx}.`);
                    return; 
                }
                const pa = document.createElement('div');
                pa.className = 'player-area';
                pa.dataset.playerId = opponent.id;
                
                const layoutData = layoutSlots[idx];
                
                pa.style.top = layoutData.top;
                pa.style.left = layoutData.left;

                const baseTX = layoutData.translateX || '0%';
                const baseTY = layoutData.translateY || '0%';
                const baseRot = layoutData.rotate || '0deg';

                pa.style.setProperty('--base-translate-x', baseTX);
                pa.style.setProperty('--base-translate-y', baseTY);
                pa.style.setProperty('--base-rotate', baseRot);
                pa.style.transform = `translateX(${baseTX}) translateY(${baseTY}) rotate(${baseRot})`;
                
                if (opponent.id === gameState.currentPlayerId) {
                    pa.classList.add('current-player'); 
                }
                
                if (opponent.eliminated) pa.classList.add('eliminated');

                const av = opponent.isHost ? '👑' : '👤';
                pa.innerHTML = `<div class="player-avatar">${av}</div><div class="player-name">${opponent.name}</div>`;

                const cardVisualsContainer = document.createElement('div');
                cardVisualsContainer.className = 'player-card-visuals has-tooltip';
                const actualCardCount = opponent.eliminated ? 0 : (opponent.cardCount !== undefined ? opponent.cardCount : 0);
                cardVisualsContainer.dataset.tooltip = `Cards: ${actualCardCount}`;
                const miniCardStep = 8; 

                if (actualCardCount > 0) {
                    const baseLeftOffset = (actualCardCount - 1) * -(miniCardStep / 2);
                    for (let i = 0; i < actualCardCount; i++) {
                        const cardElWrapper = createCardElement('X', 'X', false, true); 
                        cardElWrapper.classList.add('player-area-mini-card');
                        cardElWrapper.style.position = 'absolute';
                        cardElWrapper.style.left = `calc(50% + ${baseLeftOffset + i * miniCardStep}px)`;
                        cardElWrapper.style.bottom = `${i * 1.5}px`; 
                        cardElWrapper.style.transform = 'translateX(-50%)'; 
                        cardElWrapper.style.zIndex = i;
                        cardVisualsContainer.appendChild(cardElWrapper);
                    }
                }
                pa.appendChild(cardVisualsContainer);

                const revolverVisualsContainer = document.createElement('div');
                revolverVisualsContainer.className = 'player-revolver-visuals has-tooltip';
                const chambersLeft = opponent.revolverChambersLeft !== undefined ? opponent.revolverChambersLeft : REVOLVER_CHAMBERS;
                revolverVisualsContainer.dataset.tooltip = `Revolver Rounds: ${chambersLeft}/${REVOLVER_CHAMBERS}`;
                
                for (let i = 0; i < REVOLVER_CHAMBERS; i++) {
                    const chamberEl = document.createElement('span');
                    chamberEl.className = 'revolver-chamber';
                    if (i < chambersLeft) { 
                        chamberEl.classList.add('available');
                    } else { 
                        chamberEl.classList.add('fired');
                    }
                    revolverVisualsContainer.appendChild(chamberEl);
                }
                pa.appendChild(revolverVisualsContainer);
                
                playerAreasContainer.appendChild(pa);
            });

            if (gameState.currentPlayerId === localPlayer.id && !localPlayer.eliminated) {
                playerHandArea.classList.add('current-player-hand');
            } else {
                playerHandArea.classList.remove('current-player-hand');
            }
        }

        function renderLocalPlayerStats() {
            if (!localPlayerStatsArea || !localRevolverVisuals) return;
            const showStats = (gameState.gamePhase === 'playing' || 
                               gameState.gamePhase === 'challenge_reveal' || 
                               gameState.gamePhase === 'roulette' || 
                               gameState.gamePhase === 'roulette_resolved') && 
                              !localPlayer.eliminated;
            
            localPlayerStatsArea.style.display = showStats ? 'flex' : 'none';
            if (!showStats) return;

            localRevolverVisuals.innerHTML = '';
            const chambersLeft = localPlayer.revolverChambersLeft !== undefined ? localPlayer.revolverChambersLeft : REVOLVER_CHAMBERS;
            localRevolverVisuals.dataset.tooltip = `Revolver Rounds: ${chambersLeft}/${REVOLVER_CHAMBERS}`;

            for (let i = 0; i < REVOLVER_CHAMBERS; i++) {
                const chamberEl = document.createElement('span');
                chamberEl.className = 'revolver-chamber';
                if (i < chambersLeft) {
                    chamberEl.classList.add('available');
                } else {
                    chamberEl.classList.add('fired');
                }
                localRevolverVisuals.appendChild(chamberEl);
            }
        }


        function updateTableDisplay() { if (gameState.currentTableSuit) { tableTypeCardDiv.innerHTML = SUIT_SYMBOLS[gameState.currentTableSuit] || gameState.currentTableSuit; tableTypeCardDiv.style.color = SUIT_COLORS[gameState.currentTableSuit] || 'var(--primary-text)'; } else { tableTypeCardDiv.innerHTML = '🎲'; tableTypeCardDiv.style.color = 'var(--secondary-text)'; } if (gameState.lastPlayedTurn) { const count = gameState.lastPlayedTurn.cardsPlayedCount !== undefined ? gameState.lastPlayedTurn.cardsPlayedCount : 0; playedCardsPileInfo.textContent = `Last play: ${count} card(s) as ${SUIT_SYMBOLS[gameState.lastPlayedTurn.declaredSuit] || gameState.lastPlayedTurn.declaredSuit}.`;} else if (gameState.gamePhase === 'playing') { playedCardsPileInfo.textContent = "Awaiting first play..."; } else { playedCardsPileInfo.textContent = "---"; } updateCenterPileVisual(); }
        
        function updateCenterPileVisual() {
            if (!centerPileVisualStack) return;
            centerPileVisualStack.innerHTML = '';
            const numCardsInPile = gameState.centerPileCardCount !== undefined ? gameState.centerPileCardCount : 0;
            const maxVisualCards = 7; 

            if (numCardsInPile > 0) {
                for (let i = 0; i < Math.min(numCardsInPile, maxVisualCards); i++) {
                    const cardBackElement = createCardElement('X', 'X', false, true); 
                    const cardSvg = cardBackElement.querySelector('svg');
                    if (cardSvg) {
                        cardSvg.classList.add('card-back-dummy'); 
                        cardSvg.style.position = 'absolute';
                        const offsetX = (Math.random() - 0.5) * 4 + (i * 0.8);
                        const offsetY = (Math.random() - 0.5) * 4 - (i * 0.8);
                        cardSvg.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${(Math.random() - 0.5) * 3}deg)`;
                        cardSvg.style.zIndex = i;
                        centerPileVisualStack.appendChild(cardSvg);
                    }
                }
            }
        }

        function animatePlayedCards(playerId, numCardsPlayed) {
            if (numCardsPlayed === 0 || !gameBoardDiv) return;

            const sourceElement = (playerId === localPlayer.id) ? playerHandArea : playerAreasContainer.querySelector(`.player-area[data-player-id="${playerId}"]`);
            const targetElement = centerPileVisualStack;

            if (!sourceElement || !targetElement) {
                logDebug(`Animation source/target not found for player ${playerId}`);
                return;
            }

            const gameBoardRect = gameBoardDiv.getBoundingClientRect(); 
            const cardToAnimateContainer = createCardElement('A', 'S', false, true); 
            const cardToAnimate = cardToAnimateContainer.querySelector('svg');
            if (!cardToAnimate) return;

            const cardWidth = parseFloat(cardToAnimate.getAttribute('width'));
            const cardHeight = parseFloat(cardToAnimate.getAttribute('height'));

            cardToAnimate.style.position = 'absolute';
            cardToAnimate.style.zIndex = '100'; 
            
            const sourceRect = sourceElement.getBoundingClientRect();
            const initialX = (sourceRect.left + sourceRect.width / 2) - gameBoardRect.left - (cardWidth / 2);
            const initialY = (sourceRect.top + sourceRect.height / 2) - gameBoardRect.top - (cardHeight / 2);
            
            cardToAnimate.style.left = `${initialX}px`;
            cardToAnimate.style.top = `${initialY}px`;
            cardToAnimate.style.transform = 'scale(1.1) rotate(0deg)'; 
            cardToAnimate.style.opacity = '1';

            gameBoardDiv.appendChild(cardToAnimate);

            const targetRect = targetElement.getBoundingClientRect();
            const finalX = (targetRect.left + targetRect.width / 2) - gameBoardRect.left - (cardWidth / 2) + (Math.random() - 0.5) * 5;
            const finalY = (targetRect.top + targetRect.height / 2) - gameBoardRect.top - (cardHeight / 2) + (Math.random() - 0.5) * 5;
            const finalRotation = (Math.random() - 0.5) * 15; 

            requestAnimationFrame(() => {
                cardToAnimate.style.transition = 'left 0.6s cubic-bezier(0.3, 0, 0.4, 1), top 0.6s cubic-bezier(0.3, 0, 0.4, 1), transform 0.6s cubic-bezier(0.3, 0, 0.4, 1), opacity 0.5s ease-in 0.25s';
                requestAnimationFrame(() => {
                    cardToAnimate.style.left = `${finalX}px`;
                    cardToAnimate.style.top = `${finalY}px`;
                    cardToAnimate.style.transform = `scale(0.8) rotate(${finalRotation}deg)`; 
                    cardToAnimate.style.opacity = '0';
                });
            });

            cardToAnimate.addEventListener('transitionend', () => {
                if (cardToAnimate.parentElement) {
                    cardToAnimate.remove();
                }
            }, { once: true });
        }


        function updateActionButtons() { const amICurrentPlayer = gameState.currentPlayerId === localPlayer.id; const localPlayerData = gameState.players.find(p => p.id === localPlayer.id); const amEliminated = localPlayerData ? localPlayerData.eliminated : true; playCardsBtn.disabled = !amICurrentPlayer || amEliminated || gameState.gamePhase !== 'playing' || playConfirmArea.style.display === 'block'; callLiarBtn.disabled = !amICurrentPlayer || amEliminated || gameState.gamePhase !== 'playing' || !gameState.lastPlayedTurn || playConfirmArea.style.display === 'block'; if (amICurrentPlayer && !amEliminated) { playerHandArea.classList.add('current-player-hand'); } else { playerHandArea.classList.remove('current-player-hand');}}
        class LiarsDeckGameManager { static shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; }} static createLiarsDeck() { const d = []; SUITS.forEach(s => { RANKS.forEach(r => { d.push({ rank:r, suit:s, id: `${r}${s}` }); }); }); this.shuffleArray(d); return d;} static createTableDeck() { const sS=[...SUITS]; this.shuffleArray(sS); return sS;} static createRevolverDeck(){const d=[];for(let i=0;i<REVOLVER_CHAMBERS-REVOLVER_BULLETS;i++)d.push('blank');for(let i=0;i<REVOLVER_BULLETS;i++)d.push('lethal');this.shuffleArray(d);return d;} static dealCardsFromLiarsDeck(pl,dk,hs){pl.forEach(p=>{if(!p.eliminated){p.hand=[];for(let i=0;i<hs;i++)if(dk.length>0)p.hand.push(dk.pop());}else p.hand=[];p.cardCount=p.hand.length;});} static checkPlayedCardsTruth(pc,ts){if(!pc||pc.length===0)return true;for(const c of pc)if(c.suit!==ts)return false;return true;}}
        function sendMessage(type, payload, targetClientId = null) { const msg = JSON.stringify({ type, payload, senderId: localPlayer.id }); if (localPlayer.isHost) { if (targetClientId) { if (dataChannels[targetClientId]?.readyState === 'open') dataChannels[targetClientId].send(msg); else logDebug(`Host: DC to ${targetClientId} not open.`); } else Object.values(dataChannels).forEach(dc => { if (dc.readyState === 'open') dc.send(msg); }); } else if (clientToServerDc?.readyState === 'open') clientToServerDc.send(msg); else logDebug("Client: DC to host not open."); }
        
        function getConnectedAndActivePlayerIds() {
            const connectedClientIds = Object.keys(dataChannels).filter(id => dataChannels[id]?.readyState === 'open');
            const allPotentiallyActiveIds = [localPlayer.id, ...connectedClientIds];
            // Ensure they were part of the current game (important for rematch eligibility after players might have left and rejoined setup)
            return allPotentiallyActiveIds.filter(id => gameState.players.some(p => p.id === id));
        }

        function handleIncomingMessage(event) {
            const msg = JSON.parse(event.data);
            logDebug(`Received: ${msg.type} from ${msg.senderId === localPlayer.id ? 'Self' : (gameState.players.find(p=>p.id === msg.senderId)?.name || msg.senderId )}`);
            const oldGameStateForLog = localPlayer.isHost ? null : JSON.parse(JSON.stringify(lastLoggedGameStateForClient)); 

            if (localPlayer.isHost) {
                switch (msg.type) {
                    case 'PLAYER_ACTION_PLAY_CARDS': handleHostPlayerPlayCards(msg.senderId, msg.payload.cards); break;
                    case 'PLAYER_ACTION_CALL_LIAR': handleHostPlayerCallLiar(msg.senderId); break;
                    case 'PLAYER_TOGGLE_REMATCH_READY':
                        if (gameState.gamePhase === 'game_over') {
                            const clientId = msg.senderId;
                            const clientPlayer = gameState.players.find(p => p.id === clientId);
                            const clientName = clientPlayer ? clientPlayer.name : clientId;

                            const eligiblePlayers = getConnectedAndActivePlayerIds();
                            // Ensure this client is still considered eligible for rematch
                            if (!eligiblePlayers.includes(clientId)) {
                                logDebug(`Host: Received rematch ready from ${clientName} but they are no longer eligible (e.g. disconnected). Ignoring.`);
                                if (gameState.rematchReadyStatus.hasOwnProperty(clientId)) {
                                    delete gameState.rematchReadyStatus[clientId];
                                    broadcastGameState(); // Update clients about the voided vote
                                }
                                return;
                            }

                            gameState.rematchReadyStatus[clientId] = msg.payload.isReady;
                            logDebug(`Host: Player ${clientName} readiness: ${msg.payload.isReady}`);
                            updateRematchStatusDisplay(); // Host updates its own display

                            const allActuallyReady = eligiblePlayers.length > 0 &&
                                                     eligiblePlayers.every(id => gameState.rematchReadyStatus[id] === true);

                            if (eligiblePlayers.length >= MIN_PLAYERS && allActuallyReady) {
                                addLogMessage("All players ready! Starting rematch...", "success");
                                initializeNewGame(); 
                            } else {
                                broadcastGameState(); // Broadcast updated rematch statuses
                            }
                        }
                        break;
                    case 'CLIENT_NAME_UPDATE': const pToUpdate = gameState.players.find(p => p.id === msg.senderId); if (pToUpdate) { pToUpdate.name = msg.payload.name; logDebug(`Host: Player ${msg.senderId} updated name to ${msg.payload.name}.`); updateConnectedPlayersDisplay(); broadcastGameState(); } break;
                }
            } else { // Client-side
                switch (msg.type) {
                    case 'GAME_STATE_UPDATE':
                        const oldPhase = lastLoggedGameStateForClient?.gamePhase; // Get phase before update
                        const wasGameOver = oldPhase === 'game_over';

                        // Update local game state and player object
                        Object.assign(gameState, msg.payload.gameState);
                        localPlayer.hand = msg.payload.yourHand !== undefined ? msg.payload.yourHand : localPlayer.hand;
                        const myPlayerDataFromState = gameState.players.find(p => p.id === localPlayer.id);
                        if (myPlayerDataFromState) { Object.assign(localPlayer, myPlayerDataFromState); }

                        // Log messages for phase transitions etc.
                        if (gameState.gamePhase === 'playing' && oldGameStateForLog && Object.keys(oldGameStateForLog).length > 0) {
                            if (gameState.currentTableSuit !== oldGameStateForLog.currentTableSuit && gameState.currentTableSuit) {
                                addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system");
                            }
                            if (gameState.lastPlayedTurn && JSON.stringify(gameState.lastPlayedTurn) !== JSON.stringify(oldGameStateForLog.lastPlayedTurn)) { // Compare with oldGameStateForLog.lastPlayedTurn
                                addLogMessage(`${gameState.lastPlayedTurn.playerName} plays ${gameState.lastPlayedTurn.cardsPlayedCount} as ${SUIT_SYMBOLS[gameState.lastPlayedTurn.declaredSuit]}.`, "system");
                                animatePlayedCards(gameState.lastPlayedTurn.playerId, gameState.lastPlayedTurn.cardsPlayedCount);
                            }
                             if (gameState.currentPlayerId !== oldGameStateForLog.currentPlayerId && gameState.currentPlayerId) {
                                const currPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                                if(currPlayer) addLogMessage(`${currPlayer.name}'s turn.`, "system");
                            }
                        } else if (gameState.gamePhase === 'playing' && gameState.currentTableSuit && (!oldGameStateForLog || Object.keys(oldGameStateForLog).length === 0 || !oldGameStateForLog.currentTableSuit)){
                            addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system");
                            const currPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                            if(currPlayer) addLogMessage(`${currPlayer.name}'s turn.`, "system");
                        }

                        // UI Transitions
                        if (gameState.gamePhase === 'playing' && wasGameOver) { // Specifically handle transition from game_over to playing for rematch
                            logDebug("Client: Rematch started! Transitioning UI.");
                            if (gameOverOverlay.classList.contains('visible')) {
                                toggleModal(gameOverOverlay, false); // Explicitly hide game over modal
                            }
                            showGameBoard(); // Ensure game board is primary view and calls updateFullUI
                        } else if ((gameState.gamePhase !== 'lobby') && connectionSetupDiv.style.display !== 'none') {
                            // Initial game start from connection setup
                            showGameBoard();
                        } else if (gameState.gamePhase === 'lobby' && gameBoardDiv.style.display !== 'none') {
                            // Transitioning back to lobby (e.g. host exits)
                            showConnectionSetup();
                        }
                        
                        // Always update the full UI if not in lobby setup (showGameBoard calls updateFullUI indirectly)
                        if (gameState.gamePhase !== 'lobby' && !(gameState.gamePhase === 'playing' && wasGameOver)) {
                            // Avoid double updateFullUI if showGameBoard was called for rematch
                            updateFullUI();
                        }

                        // Update rematch button text ONLY if we are STILL in game_over phase.
                        if (gameState.gamePhase === 'game_over') {
                            if (JSON.stringify(gameState.rematchReadyStatus) !== JSON.stringify(oldGameStateForLog?.rematchReadyStatus)) {
                                updateRematchStatusDisplay(); // Update list of who is ready
                                localPlayer.readyForRematch = gameState.rematchReadyStatus[localPlayer.id] === true;
                                playAgainBtn.textContent = localPlayer.readyForRematch ? "Waiting for Others..." : "Ready for Rematch";
                                playAgainBtn.style.backgroundColor = localPlayer.readyForRematch ? 'var(--accent-green)' : 'var(--accent-gold)';
                            }
                        }

                        lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState));
                        break;
                    case 'CHALLENGE_ROULETTE_RESULTS': 
                        handleClientChallengeRouletteResults(msg.payload); 
                        lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState)); 
                        break;
                    case 'GAME_OVER': handleClientGameOver(msg.payload); lastLoggedGameStateForClient = {}; break;
                    case 'PLAYER_JOINED_ACK': clientStatusP.textContent = `Joined room! Waiting for the game to start...`; localPlayer.id = msg.payload.yourId; gameState.players = msg.payload.players; updatePlayerNameDisplay(); sendMessage('CLIENT_NAME_UPDATE', {name: localPlayer.name}); lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState)); break;
                    case 'HOST_DISCONNECTED': alert("Host disconnected. Returning to setup."); showConnectionSetup(); lastLoggedGameStateForClient = {}; break;
                }
            }
        }
        
        function initializeNewGame() {
            if (!localPlayer.isHost) return;
            logDebug("Host: Initializing new game (standard deck).");

            // 1. Get IDs of players who are still connected and were part of the last game.
            //    gameState.players still holds the list of players from the game that just concluded.
            const playerIdsFromPreviousGame = gameState.players.map(p => p.id);
            const connectedAndEligibleIds = getConnectedAndActivePlayerIds() // Uses dataChannels to check current connections
                                              .filter(id => playerIdsFromPreviousGame.includes(id)); // Must have been in last game

            // 2. Create the new player list for the new game
            let newGamePlayersList = [];
            gameState.players.forEach(oldPlayer => { // Iterate over players from previous game
                if (connectedAndEligibleIds.includes(oldPlayer.id)) {
                    newGamePlayersList.push({
                        id: oldPlayer.id,
                        name: oldPlayer.name,
                        isHost: oldPlayer.isHost,
                        eliminated: false, // Reset for new game
                        hand: [], // Will be dealt in startNewRound
                        revolverDeck: LiarsDeckGameManager.createRevolverDeck(),
                        revolverChambersLeft: REVOLVER_CHAMBERS,
                        cardCount: 0
                    });
                }
            });
            
            // Ensure host is present if they were somehow filtered out
            if (!newGamePlayersList.some(p => p.id === localPlayer.id)) {
                newGamePlayersList.unshift({ // Add host to the beginning
                    id: localPlayer.id, name: localPlayer.name, isHost: true,
                    eliminated: false, hand: [], revolverDeck: LiarsDeckGameManager.createRevolverDeck(),
                    revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0
                });
                // Deduplicate just in case (though logic should prevent double add)
                newGamePlayersList = [...new Map(newGamePlayersList.map(item => [item.id, item])).values()];
            }

            newGamePlayersList.sort((a, b) => { if (a.isHost) return -1; if (b.isHost) return 1; return a.id.localeCompare(b.id); });
            gameState.players = newGamePlayersList; // Official player list for the new game

            // Reset other game state properties
            gameState.rematchReadyStatus = {}; // Clear for the new game
            gameState.liarsDeck = LiarsDeckGameManager.createLiarsDeck();
            gameState.tableDeck = LiarsDeckGameManager.createTableDeck();
            gameState.centerPile = [];
            gameState.centerPileCardCount = 0;
            gameState.lastPlayedTurn = null;
            gameState.currentPlayerId = null; // Will be set in startNewRound

            // Host hides its own modal. Clients will hide theirs upon receiving GAME_STATE_UPDATE.
            if (gameOverOverlay.classList.contains('visible')) {
                 toggleModal(gameOverOverlay, false);
            }
            
            // Call startNewRound which will set gamePhase to 'playing' and then broadcast.
            startNewRound();
        }

        function startNewRound() { if (!localPlayer.isHost) return; logDebug("Host: Starting new round (suit based)."); if (gameState.tableDeck.length === 0) gameState.tableDeck = LiarsDeckGameManager.createTableDeck(); gameState.currentTableSuit = gameState.tableDeck.pop(); addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system"); const activePlayers = gameState.players.filter(p => !p.eliminated); if (gameState.liarsDeck.length < activePlayers.length * HAND_SIZE) { gameState.liarsDeck = LiarsDeckGameManager.createLiarsDeck(); addLogMessage("Liar's Deck (standard) reshuffled.", "system"); } LiarsDeckGameManager.dealCardsFromLiarsDeck(gameState.players, gameState.liarsDeck, HAND_SIZE); gameState.centerPile = []; gameState.centerPileCardCount = 0; gameState.lastPlayedTurn = null; const uneliminatedPlayers = gameState.players.filter(p => !p.eliminated); if (uneliminatedPlayers.length === 0) { logDebug("Error: No uneliminated players."); return; } let currentPlayerIndex = 0; if (gameState.currentPlayerId) { const lastPlayerOrderIndex = gameState.players.findIndex(p => p.id === gameState.currentPlayerId); if (lastPlayerOrderIndex !== -1) { currentPlayerIndex = (lastPlayerOrderIndex + 1) % gameState.players.length; }} let attempts = 0; while (attempts < gameState.players.length && gameState.players[currentPlayerIndex].eliminated) { currentPlayerIndex = (currentPlayerIndex + 1) % gameState.players.length; attempts++; } if (gameState.players[currentPlayerIndex].eliminated) { logDebug("Error: Could not find uneliminated starting player."); const firstActiveFallback = gameState.players.findIndex(p => !p.eliminated); if (firstActiveFallback !== -1) currentPlayerIndex = firstActiveFallback; else { logDebug("CRITICAL Error: No uneliminated players."); return; }} gameState.currentPlayerId = gameState.players[currentPlayerIndex].id; gameState.gamePhase = 'playing'; const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name || "Unknown"; addLogMessage(`${currentPlayerName}'s turn.`, "system"); broadcastGameState(); }
        
        function handleHostPlayerPlayCards(playerId, playedCardIds) { 
            if (!localPlayer.isHost || playerId !== gameState.currentPlayerId || gameState.gamePhase !== 'playing') return; 
            const player = gameState.players.find(p => p.id === playerId); 
            if (!player || player.eliminated) return; 
            if (!playedCardIds || playedCardIds.length === 0 || playedCardIds.length > 3) { logDebug(`Invalid play count for ${playerId}.`); return; } 
            const actualPlayedCards = []; const remainingHand = []; 
            player.hand.forEach(card => { (playedCardIds.includes(card.id)) ? actualPlayedCards.push(card) : remainingHand.push(card); }); 
            if (actualPlayedCards.length !== playedCardIds.length) { logDebug(`Card mismatch for ${playerId}.`); return; } 
            player.hand = remainingHand; player.cardCount = player.hand.length; 
            gameState.lastPlayedTurn = { playerId, playerName: player.name, cardsPlayed: actualPlayedCards, cardsPlayedCount: actualPlayedCards.length, declaredSuit: gameState.currentTableSuit }; 
            gameState.centerPile.push(...actualPlayedCards); gameState.centerPileCardCount = gameState.centerPile.length; 
            addLogMessage(`${player.name} plays ${actualPlayedCards.length} as ${SUIT_SYMBOLS[gameState.currentTableSuit]}.`, "system"); 
            
            if (gameBoardDiv.style.display === 'block') {
                animatePlayedCards(playerId, actualPlayedCards.length);
            }

            let currentIdx = gameState.players.findIndex(p => p.id === playerId); 
            let attempts = 0; let nextFound = false; 
            if (gameState.players.length > 0) { 
                do { currentIdx = (currentIdx + 1) % gameState.players.length; attempts++; if (!gameState.players[currentIdx].eliminated) { nextFound = true; break; } } while (attempts < gameState.players.length * 2); 
            } 
            if (nextFound) gameState.currentPlayerId = gameState.players[currentIdx].id; 
            else logDebug("No next player found after play."); 
            const totalCardsInHands = gameState.players.reduce((sum, p) => sum + (p.eliminated ? 0 : p.hand.length), 0); 
            if (totalCardsInHands === 0 && gameState.liarsDeck.length === 0) { 
                addLogMessage("All cards played! Auto-challenge.", "system"); 
                if (nextFound) handleHostPlayerCallLiar(gameState.players[currentIdx].id); 
                else logDebug("All cards played, no challenger."); 
                return; 
            } 
            broadcastGameState(); 
        }

        function handleHostPlayerCallLiar(challengerId) { if (!localPlayer.isHost || challengerId !== gameState.currentPlayerId || !gameState.lastPlayedTurn || gameState.gamePhase !== 'playing') return; const challenger = gameState.players.find(p => p.id === challengerId); const accusedId = gameState.lastPlayedTurn.playerId; const accused = gameState.players.find(p => p.id === accusedId); if (!challenger || challenger.eliminated || !accused) { logDebug("Challenge error: invalid players."); return; } addLogMessage(`${challenger.name} calls LIAR! on ${accused.name}.`, "system"); gameState.gamePhase = 'challenge_reveal'; const played = gameState.lastPlayedTurn.cardsPlayed; const tableSuit = gameState.currentTableSuit; const wasLie = !LiarsDeckGameManager.checkPlayedCardsTruth(played, tableSuit); let rouletteTargetId; if (wasLie) { addLogMessage(`${accused.name} was LYING! (Not all ${SUIT_SYMBOLS[tableSuit]})`, "error"); rouletteTargetId = accusedId; } else { addLogMessage(`${accused.name} was TRUTHFUL! (All ${SUIT_SYMBOLS[tableSuit]})`, "success"); rouletteTargetId = challengerId; } const target = gameState.players.find(p => p.id === rouletteTargetId); if (!target || target.eliminated) { logDebug(`Roulette target ${target?.name || rouletteTargetId} gone.`); startNewRound(); return; } if (!target.revolverDeck || target.revolverDeck.length === 0) { target.revolverDeck = LiarsDeckGameManager.createRevolverDeck(); target.revolverChambersLeft = REVOLVER_CHAMBERS; addLogMessage(`${target.name}'s revolver reloaded.`, "system"); } const fired = target.revolverDeck.pop(); target.revolverChambersLeft = target.revolverDeck.length; let outcomeText; if (fired === 'lethal') { target.eliminated = true; target.cardCount = 0; outcomeText = `BANG! ${target.name} ELIMINATED!`; addLogMessage(outcomeText, "error"); } else { outcomeText = `CLICK! ${target.name} survives.`; addLogMessage(outcomeText, "system"); if (target.revolverDeck.length === 0) { addLogMessage(`${target.name}'s revolver empty, reloaded.`, "system"); target.revolverDeck = LiarsDeckGameManager.createRevolverDeck(); target.revolverChambersLeft = REVOLVER_CHAMBERS;}} gameState.players.forEach(p => p.cardCount = p.eliminated ? 0 : p.hand.length); const results = { challenger:{id:challenger.id,name:challenger.name}, accused:{id:accused.id,name:accused.name}, playedCards:played, tableSuit:tableSuit, claimWasLie:wasLie, rouletteTarget:{id:target.id,name:target.name}, rouletteOutcome:fired, rouletteOutcomeText:outcomeText, updatedPlayersData: gameState.players.map(p=>({id:p.id,name:p.name,eliminated:p.eliminated,revolverChambersLeft:p.revolverChambersLeft,cardCount:p.cardCount}))}; sendMessage('CHALLENGE_ROULETTE_RESULTS',results); handleClientChallengeRouletteResults(results); const uneliminated = gameState.players.filter(p=>!p.eliminated); if(uneliminated.length<=1){gameState.gamePhase='game_over';const winner=uneliminated.length===1?uneliminated[0]:null;const goData={winner:winner?{id:winner.id,name:winner.name}:null,reason:winner?`${winner.name} is the last one standing!`:"It's a draw... or mutual destruction!"};sendMessage('GAME_OVER',goData);handleClientGameOver(goData);}else{gameState.gamePhase='roulette_resolved';broadcastGameState();setTimeout(()=>{if(gameState.gamePhase==='roulette_resolved')startNewRound();},3500);}}
        
        function handleClientChallengeRouletteResults(data) { 
            rouletteResultTextP.textContent = ''; 
            if (localPlayer.id !== data.challenger.id && localPlayer.id !== data.accused.id) { 
                addLogMessage(`${data.challenger.name} calls LIAR! on ${data.accused.name}.`, "system");
            }
            if (data.claimWasLie) { addLogMessage(`${data.accused.name} was LYING! (Not all ${SUIT_SYMBOLS[data.tableSuit]})`, "error");} 
            else { addLogMessage(`${data.accused.name} was TRUTHFUL! (All ${SUIT_SYMBOLS[data.tableSuit]})`, "success");}

            gameState.gamePhase = 'roulette'; 
            data.updatedPlayersData.forEach(updP => { const pLocal = gameState.players.find(p => p.id === updP.id); if (pLocal) Object.assign(pLocal, updP); if (localPlayer.id === updP.id) Object.assign(localPlayer, updP); }); 
            challengeRouletteTitle.textContent = data.claimWasLie ? `${data.accused.name} CAUGHT LYING!` : `CHALLENGE FAILED!`; 
            challengeRouletteDetailsP.textContent = `${data.challenger.name} challenged ${data.accused.name}. Claimed Suit: ${SUIT_SYMBOLS[data.tableSuit]}.`; 
            revealedCardsDisplay.innerHTML = ''; data.playedCards.forEach(c => revealedCardsDisplay.appendChild(createCardElement(c.rank, c.suit, true, true))); 
            challengeRouletteConsequenceP.textContent = `${data.rouletteTarget.name} faces the Roulette!`; 
            
            if (rouletteSymbolInterval) clearInterval(rouletteSymbolInterval);
            const rouletteSymbols = ['<span style="font-size:2em; padding: 0 5px;">🃏</span>', '<span style="font-size:2em; padding: 0 5px;">🎲</span>', '<span style="font-size:2em; padding: 0 5px;">❔</span>', '<span style="font-size:2em; padding: 0 5px;">💀</span>', '<span style="font-size:2em; padding: 0 5px;">🤞</span>'];
            let symbolIndex = 0;
            rouletteAnimationDiv.innerHTML = rouletteSymbols[0];
            rouletteAnimationDiv.classList.add('spinning');
            
            rouletteSymbolInterval = setInterval(() => {
                symbolIndex = (symbolIndex + 1) % rouletteSymbols.length;
                rouletteAnimationDiv.innerHTML = rouletteSymbols[symbolIndex];
            }, 150);

            setTimeout(() => {
                if (rouletteSymbolInterval) clearInterval(rouletteSymbolInterval);
                rouletteAnimationDiv.classList.remove('spinning'); 
                rouletteAnimationDiv.innerHTML = data.rouletteOutcome === 'lethal' ? `<span style="font-size:2.2em; color: var(--accent-red-darker); font-weight:bold;">💥 BANG! 💥</span>` : `<span style="font-size:2.2em; color: var(--accent-green-darker); font-weight:bold;">💨 Click! 💨</span>`;
                rouletteResultTextP.textContent = data.rouletteOutcomeText; 
                rouletteResultTextP.style.color = data.rouletteOutcome === 'lethal' ? 'var(--accent-red)' : 'var(--accent-green)';
                addLogMessage(data.rouletteOutcomeText, data.rouletteOutcome === 'lethal' ? "error" : "system"); 
            }, 2000); 
            
            toggleModal(challengeRouletteOverlay, true); updateFullUI(); 
        }

        function updateRematchStatusDisplay() {
            if (gameState.gamePhase !== 'game_over' || !rematchStatusContainer) {
                if(rematchStatusContainer) rematchStatusContainer.style.display = 'none';
                return;
            }
            rematchStatusContainer.style.display = 'block';
            rematchStatusListDiv.innerHTML = '';

            const eligibleForRematchDisplay = getConnectedAndActivePlayerIds();
            
            eligibleForRematchDisplay.forEach(playerId => {
                const player = gameState.players.find(p => p.id === playerId);
                if (player) { // Ensure player data exists
                    const statusSpan = document.createElement('span');
                    const isReady = gameState.rematchReadyStatus[playerId] === true; // Explicitly check for true
                    statusSpan.textContent = `${player.name}: ${isReady ? 'Ready 👍' : 'Not Ready...'}`;
                    statusSpan.className = isReady ? 'ready' : 'not-ready';
                    rematchStatusListDiv.appendChild(statusSpan);
                }
            });
        }

        function handleClientGameOver(data) {
            gameState.gamePhase = 'game_over';
            gameState.rematchReadyStatus = {}; // Clear previous game's statuses completely
            
            // Initialize rematch status for all currently connected and eligible players to false
            const eligibleForRematchInit = getConnectedAndActivePlayerIds();
            eligibleForRematchInit.forEach(id => {
                gameState.rematchReadyStatus[id] = false;
            });

            localPlayer.readyForRematch = false; // Reset local player's button state

            gameOverTitle.textContent = data.winner ? `👑 ${data.winner.name} Wins! 👑` : "Game Over!";
            gameOverMessageP.textContent = data.reason;
            addLogMessage(data.reason, "system");

            playAgainBtn.textContent = "Ready for Rematch";
            playAgainBtn.style.backgroundColor = 'var(--accent-gold)';
            playAgainBtn.disabled = false;

            updateRematchStatusDisplay();
            toggleModal(gameOverOverlay, true);
            toggleModal(challengeRouletteOverlay, false);
            updateActionButtons(); // Disables in-game buttons
            updateFullUI(); // Renders areas, which might show "eliminated" status more clearly etc.
        }

        function broadcastGameState() { 
            if (!localPlayer.isHost) return; 
            const common = { 
                players: gameState.players.map(p => ({ id: p.id, name: p.name, isHost: p.isHost, eliminated: p.eliminated, revolverChambersLeft: p.revolverChambersLeft, cardCount: p.cardCount })), 
                currentPlayerId: gameState.currentPlayerId, 
                currentTableSuit: gameState.currentTableSuit, 
                lastPlayedTurn: gameState.lastPlayedTurn ? { playerId:gameState.lastPlayedTurn.playerId,playerName:gameState.lastPlayedTurn.playerName,cardsPlayedCount:gameState.lastPlayedTurn.cardsPlayedCount,declaredSuit:gameState.lastPlayedTurn.declaredSuit}:null, 
                gamePhase: gameState.gamePhase, 
                roomName: gameState.roomName, 
                centerPileCardCount: gameState.centerPile.length,
                rematchReadyStatus: gameState.rematchReadyStatus 
            }; 
            gameState.players.forEach(p => { 
                if (p.id !== localPlayer.id && dataChannels[p.id]?.readyState === 'open') { 
                    sendMessage('GAME_STATE_UPDATE', { gameState: { ...common }, yourHand: p.hand }, p.id); 
                } 
            }); 
            const myPData = gameState.players.find(p => p.id === localPlayer.id); 
            if (myPData) Object.assign(localPlayer, myPData); 
            updateFullUI(); 
        }
        function showConnectionSetup() { connectionSetupDiv.style.display = 'flex'; gameBoardDiv.style.display = 'none'; toggleModal(gameOverOverlay, false); toggleModal(challengeRouletteOverlay, false); hostControlsDiv.style.display = 'none'; clientControlsDiv.style.display = 'none'; hostConnectionSlotsDiv.innerHTML = ''; connectedPlayersCountSpan.textContent = '0'; connectedPlayersListDiv.innerHTML = ''; startGameBtn.disabled = true; hostOfferInput.value = ''; clientAnswerOutput.value = ''; clientStatusP.textContent = ''; const currentName = playerNameInput.value || localPlayer.name; localPlayer = { id: null, name: currentName, isHost: false, hand: [], eliminated: false, revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount:0, readyForRematch: false }; if(currentName) playerNameInput.value = currentName; gameState = { players: [], liarsDeck: [], tableDeck: [], centerPile: [], currentPlayerId: null, currentTableSuit: null, lastPlayedTurn: null, gamePhase: 'lobby', roomName: null, config: { handSize: HAND_SIZE }, centerPileCardCount: 0, rematchReadyStatus: {} }; Object.values(peerConnections).forEach(pc => {if(pc?.close)pc.close();}); if(clientToServerPc?.close)clientToServerPc.close(); peerConnections = {}; clientToServerPc = null; dataChannels = {}; clientToServerDc = null; hostOfferInputs = {}; logDebug("UI reset to connection setup."); lastLoggedGameStateForClient = {}; logMessagesDiv.innerHTML = ''; localPlayerStatsArea.style.display = 'none';}
        
        function showGameBoard() {
            connectionSetupDiv.style.display = 'none';
            gameBoardDiv.style.display = 'block';
            if (gameOverOverlay.classList.contains('visible')) { // Ensure game over modal is hidden
                toggleModal(gameOverOverlay, false);
            }
            if (challengeRouletteOverlay.classList.contains('visible')) { // Also hide challenge modal
                toggleModal(challengeRouletteOverlay, false);
            }
            updateFullUI();
        }
        
        function updateFullUI() { 
            if (gameState.gamePhase === 'lobby' && gameBoardDiv.style.display === 'none') return; 
            renderPlayerHand(); 
            renderPlayerAreas(); 
            renderLocalPlayerStats(); 
            updateTableDisplay(); 
            updateActionButtons(); 
            if (playConfirmArea.style.display === 'block') { 
                const amICurr = gameState.currentPlayerId === localPlayer.id; 
                if(!amICurr || gameState.gamePhase !== 'playing') { 
                    enableHandCardSelectionForPlay(false); 
                }
            }
            if (gameState.gamePhase === 'game_over') { 
                updateRematchStatusDisplay();
            }
        }

        function updatePlayerNameDisplay() { playerNameInput.value = localPlayer.name; }
        
        function setupHostSlot(sIdx) {
            if (!hostOfferInputs[sIdx]?.slotDiv) {
                const sD = document.createElement('div');
                sD.className = 'connection-slot';
                sD.id = `slot-${sIdx}`;

                const oL = document.createElement('p');
                oL.textContent = `Client ${sIdx + 1} Offer (Share with them):`;

                const offerVisualContainer = document.createElement('div');
                offerVisualContainer.className = 'textarea-container-visual'; 

                const oT = document.createElement('textarea'); 
                oT.readOnly = true;
                oT.id = `hostOfferSdp-${sIdx}`;
                oT.rows = 3; 
                offerVisualContainer.appendChild(oT); 

                const copyOfferBtn = document.createElement('button');
                copyOfferBtn.textContent = 'COPY'; 
                copyOfferBtn.title = 'Copy Offer'; 
                copyOfferBtn.className = 'copy-btn-internal'; 
                copyOfferBtn.type = 'button';
                copyOfferBtn.onclick = () => copyToClipboard(oT.value, copyOfferBtn);
                offerVisualContainer.appendChild(copyOfferBtn); 

                const aL = document.createElement('p');
                aL.textContent = `Client ${sIdx + 1} Answer (Paste from them):`;
                const aT = document.createElement('textarea'); 
                aT.id = `clientAnswerSdp-${sIdx}`;
                aT.rows = 3;
                // Apply general textarea styling for host's answer input
                aT.style.width = 'calc(100% - 24px)';
                aT.style.maxWidth = '500px';
                aT.style.margin = '10px auto';
                aT.style.padding = '12px';
                aT.style.borderRadius = 'var(--border-radius)';
                aT.style.border = '1px solid var(--input-border)';
                aT.style.backgroundColor = 'var(--input-bg)';
                aT.style.color = 'var(--input-text)';
                aT.style.fontSize = '1em';
                aT.style.fontFamily = 'var(--font-family)';


                const cB = document.createElement('button');
                cB.textContent = 'Process Answer';

                sD.appendChild(oL);
                sD.appendChild(offerVisualContainer); 
                sD.appendChild(aL);
                sD.appendChild(aT);
                sD.appendChild(cB);
                hostConnectionSlotsDiv.appendChild(sD);
                hostOfferInputs[sIdx] = { offerTextarea: oT, answerTextarea: aT, connectBtn: cB, slotDiv: sD, copyOfferBtn: copyOfferBtn };
                cB.onclick = () => processClientAnswer(sIdx, aT.value);
            } else {
                hostOfferInputs[sIdx].offerTextarea.value = "Generating...";
                hostOfferInputs[sIdx].answerTextarea.value = "";
                hostOfferInputs[sIdx].answerTextarea.disabled = false;
                hostOfferInputs[sIdx].connectBtn.disabled = false;
                hostOfferInputs[sIdx].slotDiv.classList.remove('connected');
            }
            const cId = `client-${sIdx}`;
            if (peerConnections[cId]) { peerConnections[cId].close(); delete peerConnections[cId]; }
            if (dataChannels[cId]) delete dataChannels[cId];
            const pc = new RTCPeerConnection(STUN_SERVERS);
            peerConnections[cId] = pc;
            const updOffTxt = () => { if (hostOfferInputs[sIdx]?.offerTextarea && pc.localDescription?.sdp) { try { hostOfferInputs[sIdx].offerTextarea.value = JSON.stringify(pc.localDescription); } catch (e) { hostOfferInputs[sIdx].offerTextarea.value = "Error stringify."; } } else if (hostOfferInputs[sIdx]?.offerTextarea.value.startsWith("Generating")) { hostOfferInputs[sIdx].offerTextarea.value = "Error: SDP not ready."; } };
            pc.onicecandidate = e => { updOffTxt(); };
            pc.oniceconnectionstatechange = () => { logDebug(`Host: ICE ${cId}: ${pc.iceConnectionState}`); if (['disconnected', 'failed', 'closed'].includes(pc.iceConnectionState) && peerConnections[cId] === pc) handleClientDisconnect(cId); };
            const dc = pc.createDataChannel(`chat-${cId}`, { reliable: true });
            dc.onopen = () => { 
                logDebug(`Host: DC OPEN ${cId}`); 
                dataChannels[cId] = dc; 
                const nip = cId; 
                let p = gameState.players.find(plr => plr.id === nip); 
                if (!p) { p = { id: nip, name: `Player ${Object.keys(dataChannels).length + 1}`, isHost: false, eliminated: false, hand: [], revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0 }; gameState.players.push(p); } 
                else p.name = `Player ${Object.keys(dataChannels).length + 1}`; 
                updateConnectedPlayersDisplay(); 
                sendMessage('PLAYER_JOINED_ACK', { yourId: nip, hostName: localPlayer.name, players: gameState.players.map(pl => ({ id: pl.id, name: pl.name, isHost: pl.isHost, cardCount: pl.cardCount })) }, nip); 
                hostOfferInputs[sIdx].connectBtn.disabled = true; 
                hostOfferInputs[sIdx].answerTextarea.disabled = true; 
                hostOfferInputs[sIdx].slotDiv.classList.add('connected'); 
            };
            dc.onmessage = handleIncomingMessage; dc.onclose = () => { logDebug(`Host: DC CLOSE ${cId}`); if (dataChannels[cId] === dc) handleClientDisconnect(cId); }; dc.onerror = err => logDebug(`Host: DC error ${cId}: ${err}`); pc.createOffer().then(off => pc.setLocalDescription(off)).then(updOffTxt).catch(e => { if (hostOfferInputs[sIdx]?.offerTextarea) hostOfferInputs[sIdx].offerTextarea.value = `Error offer: ${e.message}`; });
        }

        function processClientAnswer(sIdx,ansSdpStr){const cid=`client-${sIdx}`;const pc=peerConnections[cid];if(!pc||pc.signalingState==="closed"){logDebug(`Host: PC ${cid} invalid.`);return;}try{const ans=JSON.parse(ansSdpStr);pc.setRemoteDescription(new RTCSessionDescription(ans)).catch(e=>logDebug(`Host: Error setRemoteDesc ${cid}: ${e}`));}catch(e){alert("Invalid Answer SDP. Make sure it's copied correctly.");}}
        
        function handleClientDisconnect(cId){
            logDebug(`Host: Client ${gameState.players.find(p=>p.id===cId)?.name||cId} disconnect.`);
            const dP = gameState.players.find(p=>p.id===cId);

            // Close and delete peer connection and data channel first
            if(peerConnections[cId]){peerConnections[cId].close();delete peerConnections[cId];}
            if(dataChannels[cId])delete dataChannels[cId]; // This makes them ineligible in getConnectedAndActivePlayerIds

            let gameLogicChanged = false; // Flag to determine if a broadcast is needed if game doesn't end/restart

            if(dP){
                if (gameState.gamePhase === 'game_over') {
                    let statusActuallyChanged = false;
                    if (gameState.rematchReadyStatus.hasOwnProperty(cId)) {
                        delete gameState.rematchReadyStatus[cId];
                        statusActuallyChanged = true; // Vote was removed
                    }
                    // The fact that a player disconnected means the pool of eligible players for rematch effectively changed.
                    addLogMessage(`${dP.name} disconnected. No longer part of rematch consideration.`, "system");
                    statusActuallyChanged = true; // Mark that the set of who *can* rematch has changed

                    const eligibleRematchPlayers = getConnectedAndActivePlayerIds(); // Will be smaller now, excluding cId
                    const allActuallyReady = eligibleRematchPlayers.length > 0 &&
                                             eligibleRematchPlayers.every(id => gameState.rematchReadyStatus[id] === true);

                    if (eligibleRematchPlayers.length >= MIN_PLAYERS && allActuallyReady) {
                        addLogMessage("All remaining players ready! Starting rematch...", "success");
                        initializeNewGame(); // This will broadcast the new game state
                    } else if (statusActuallyChanged) { // If game didn't restart but status/eligibility changed
                         broadcastGameState(); // Update clients about the disconnection and new rematch eligibility
                    }
                    // gameLogicChanged is effectively handled by statusActuallyChanged for this block
                } else if (!dP.eliminated && ['playing','challenge_reveal','roulette','roulette_resolved'].includes(gameState.gamePhase)){
                    dP.eliminated=true; dP.cardCount=0; addLogMessage(`${dP.name} disconnected & was eliminated.`, "system"); gameLogicChanged=true;
                    const unelim=gameState.players.filter(p=>!p.eliminated);
                    if(unelim.length<=1 && gameState.gamePhase!=='game_over'){ // Check if game should end
                        gameState.gamePhase='game_over';
                        const winner=unelim.length===1?unelim[0]:null;
                        const goD={winner:winner?{id:winner.id,name:winner.name}:null,reason:winner?`${winner.name} wins by default (opponent disconnected)!`:"Game ended due to disconnections."};
                        sendMessage('GAME_OVER',goD); // This will trigger GAME_OVER on host too via handleClientGameOver
                        // handleClientGameOver will then set up rematch state correctly
                    } else if(gameState.gamePhase!=='game_over' && gameState.currentPlayerId===cId){ // Pass turn if current player
                        let cpi=gameState.players.findIndex(p=>p.id===cId);
                        let att=0;let nextF=false;
                        if(gameState.players.length>0){
                            do {cpi=(cpi+1)%gameState.players.length;att++;if(!gameState.players[cpi].eliminated){nextF=true;break;}}
                            while(att<gameState.players.length*2);
                        }
                        if(nextF){gameState.currentPlayerId=gameState.players[cpi].id;addLogMessage(`Turn passed to ${gameState.players.find(p=>p.id===gameState.currentPlayerId)?.name}.`,"system");}
                        else logDebug("Disconnect: No next player found.");
                        // gameLogicChanged is true, so broadcast will happen below if not game_over
                    }
                    // If gameLogicChanged and not game_over phase yet, broadcast will be handled outside this 'if (dP)'
                } else if(gameState.gamePhase==='lobby'){
                    gameState.players=gameState.players.filter(p=>p.id!==cId);
                    gameLogicChanged=true;
                    // Broadcast for lobby will be handled outside 'if (dP)'
                }
            } // end if(dP)

            updateConnectedPlayersDisplay(); // For host's lobby UI slots
            const sIdxStr=cId.split('-')[1];
            if(localPlayer.isHost&&sIdxStr&&!isNaN(parseInt(sIdxStr))){
                const sIdx=parseInt(sIdxStr);
                logDebug(`Host: Reset slot ${sIdx} for ${cId}.`);
                if(hostOfferInputs[sIdx]?.slotDiv)hostOfferInputs[sIdx].slotDiv.classList.remove('connected');
                setupHostSlot(sIdx); // Re-initialize the slot for a new connection
            }

            // General broadcast if game logic changed and not handled by a phase transition (like to game_over or new_game)
            if(gameLogicChanged && gameState.gamePhase !== 'game_over' && gameState.gamePhase !== 'playing_starting_new_round') { // playing_starting_new_round is hypothetical name for during initializeNewGame
                 // Check if not already handled by initializeNewGame or similar state transitions from above
                if(!(gameState.gamePhase === 'game_over' && dP && (gameState.players.filter(p=>!p.eliminated).length <=1) )) { // if not already handled by game ending
                     if (gameState.gamePhase !== 'lobby' || (gameState.gamePhase === 'lobby' && dP)) { // broadcast for lobby only if a player was actually removed
                        broadcastGameState();
                     }
                }
            }
        }

        function updateConnectedPlayersDisplay(){const openDCIds=Object.keys(dataChannels).filter(id=>dataChannels[id]?.readyState==='open');const dispPs=gameState.players.filter(p=>p.isHost||openDCIds.includes(p.id));connectedPlayersCountSpan.textContent=`${dispPs.length-(localPlayer.isHost?1:0)} / ${MAX_PLAYERS-1}`;connectedPlayersListDiv.innerHTML='';dispPs.filter(p => !p.isHost).forEach(p=>{const s=document.createElement('span');s.textContent=p.name;connectedPlayersListDiv.appendChild(s);});if(localPlayer.isHost){ const hostSpan = document.createElement('span'); hostSpan.textContent = `${localPlayer.name} (Host)`; hostSpan.style.fontWeight = 'bold'; connectedPlayersListDiv.prepend(hostSpan); }startGameBtn.disabled=!(dispPs.length>=MIN_PLAYERS&&dispPs.length<=MAX_PLAYERS);}
        function clientGenerateAnswer(){const offS=hostOfferInput.value;if(!offS){alert("Please paste the Host's Offer code first.");return;}if(clientToServerPc&&clientToServerPc.signalingState!=="closed"){clientToServerPc.close();clientToServerPc=null;}clientToServerPc=new RTCPeerConnection(STUN_SERVERS);const updAnsTxt=()=>{if(clientToServerPc.localDescription?.sdp){try{clientAnswerOutput.value=JSON.stringify(clientToServerPc.localDescription);}catch(e){clientAnswerOutput.value="Error stringifying Answer SDP.";}}};clientToServerPc.onicecandidate=e=>{updAnsTxt();};clientToServerPc.oniceconnectionstatechange=()=>{logDebug(`Client: ICE state: ${clientToServerPc.iceConnectionState}`); if(clientToServerPc.iceConnectionState==='connected'){clientStatusP.textContent="Successfully connected to Host! Waiting for game...";clientStatusP.style.color='var(--accent-green)';}if(['disconnected','failed','closed'].includes(clientToServerPc.iceConnectionState)){clientStatusP.textContent="Disconnected from Host.";clientStatusP.style.color='var(--accent-red)';if(clientToServerPc.iceConnectionState!=='closed' && gameState.gamePhase !== 'game_over' && gameState.gamePhase !== 'lobby' ){showConnectionSetup();}}};clientToServerPc.ondatachannel=e=>{clientToServerDc=e.channel;clientToServerDc.onmessage=handleIncomingMessage;clientToServerDc.onopen=()=>{logDebug("Client: Data Channel OPEN.");clientStatusP.textContent="Data channel open. Ready!";};clientToServerDc.onclose=()=>{clientStatusP.textContent="Data channel closed by Host.";clientStatusP.style.color='var(--accent-red)';if(gameState.gamePhase !== 'game_over' && gameState.gamePhase !== 'lobby') showConnectionSetup();};};try{const off=JSON.parse(offS);clientToServerPc.setRemoteDescription(new RTCSessionDescription(off)).then(()=>clientToServerPc.createAnswer()).then(ans=>clientToServerPc.setLocalDescription(ans)).then(()=>{updAnsTxt();clientStatusP.textContent="Answer generated. Copy it and send to the Host.";clientStatusP.style.color='var(--accent-highlight)';}).catch(e=>{clientStatusP.textContent=`Error generating answer: ${e.message}`;clientStatusP.style.color='var(--accent-red-darker)';logDebug(`Client answer error: ${e}`);});}catch(e){alert("Invalid Host Offer SDP. Please ensure it's copied correctly.");clientStatusP.textContent="Error: Invalid Offer format.";clientStatusP.style.color='var(--accent-red-darker)';}}
        function handleHandCardClickForPlay(event){const cE=event.currentTarget;const cId=cE.dataset.cardId;const idx=selectedCardsForPlayUI.findIndex(c=>c.id===cId);if(idx>-1){selectedCardsForPlayUI.splice(idx,1);cE.classList.remove('selected-for-play');}else{if(selectedCardsForPlayUI.length<3){const cardInH=localPlayer.hand.find(c=>c.id===cId);if(cardInH){selectedCardsForPlayUI.push(cardInH);cE.classList.add('selected-for-play');}}else addLogMessage("Max 3 cards can be selected.", "error");}updatePlayConfirmArea();}
        function updatePlayConfirmArea(){if(selectedCardsForPlayUI.length>0&&gameState.currentTableSuit){playConfirmText.textContent=`Play ${selectedCardsForPlayUI.length} card${selectedCardsForPlayUI.length > 1 ? 's' : ''} as ${SUIT_SYMBOLS[gameState.currentTableSuit]}?`;playConfirmArea.style.display='block';}else playConfirmArea.style.display='none';}
        function enableHandCardSelectionForPlay(enable){const hCs=playerHandArea.querySelectorAll('.card-container');if(enable){selectedCardsForPlayUI=[];playerHandArea.classList.add('card-selection-active');playerHandArea.classList.remove('current-player-hand'); hCs.forEach(c=>{c.classList.remove('selected-for-play');c.addEventListener('click',handleHandCardClickForPlay);});playCardsBtn.disabled=true;callLiarBtn.disabled=true;updatePlayConfirmArea();}else{playerHandArea.classList.remove('card-selection-active');if(gameState.currentPlayerId === localPlayer.id && !localPlayer.eliminated) playerHandArea.classList.add('current-player-hand');hCs.forEach(c=>{c.classList.remove('selected-for-play');c.removeEventListener('click',handleHandCardClickForPlay);});playConfirmArea.style.display='none';selectedCardsForPlayUI=[];updateActionButtons();}}
        
        function init() { 
            createRoomBtn.onclick=()=>{localPlayer.name=playerNameInput.value.trim();if(localPlayer.name.length<3){alert("Name must be at least 3 characters long.");return;}localPlayer.isHost=true;localPlayer.id=generateId("host_");gameState.roomName=`${localPlayer.name}'s Game (${generateId().substring(0,4)})`; gameState.players=[{id:localPlayer.id,name:localPlayer.name,isHost:true,eliminated:false,hand:[],revolverDeck:[],revolverChambersLeft:REVOLVER_CHAMBERS,cardCount:0}];updatePlayerNameDisplay();hostControlsDiv.style.display='block';clientControlsDiv.style.display='none';hostConnectionSlotsDiv.innerHTML='';hostOfferInputs={};for(let i=0;i<MAX_PLAYERS-1;i++)setupHostSlot(i);updateConnectedPlayersDisplay();logDebug(`Host ${localPlayer.name} created room (debug: ${gameState.roomName})`);addLogMessage("Room created. Waiting for players...", "system");}; 
            joinRoomBtn.onclick=()=>{localPlayer.name=playerNameInput.value.trim();if(localPlayer.name.length<3){alert("Name must be at least 3 characters long.");return;}localPlayer.isHost=false;updatePlayerNameDisplay();hostControlsDiv.style.display='none';clientControlsDiv.style.display='block';logDebug(`Player ${localPlayer.name} attempting to join a room.`);clientStatusP.textContent="Ready to join. Paste Host Offer and Generate Answer."; clientStatusP.style.color = "var(--secondary-text)";}; 
            
            const copyClientAnswerBtn = $('#copyClientAnswerBtn');
            if (copyClientAnswerBtn) {
                copyClientAnswerBtn.onclick = () => copyToClipboard(clientAnswerOutput.value, copyClientAnswerBtn);
            }

            generateAnswerBtn.onclick=clientGenerateAnswer; 
            startGameBtn.onclick=()=>{if(localPlayer.isHost){const connPs=gameState.players.filter(p=>p.isHost||(dataChannels[p.id]?.readyState==='open'));if(connPs.length<MIN_PLAYERS){alert(`Need at least ${MIN_PLAYERS} players to start. Currently have ${connPs.length}.`);return;}logDebug("Host starting game (standard deck)...");addLogMessage("Game starting!", "success");initializeNewGame();showGameBoard();}}; 
            playCardsBtn.onclick=()=>{enableHandCardSelectionForPlay(true);}; 
            confirmPlayBtn.onclick=()=>{if(selectedCardsForPlayUI.length>0&&selectedCardsForPlayUI.length<=3){const cIds=selectedCardsForPlayUI.map(c=>c.id);if(localPlayer.isHost)handleHostPlayerPlayCards(localPlayer.id,cIds);else sendMessage('PLAYER_ACTION_PLAY_CARDS',{cards:cIds});enableHandCardSelectionForPlay(false);}else alert("Please select 1 to 3 cards to play.");}; 
            cancelPlayBtn.onclick=()=>{enableHandCardSelectionForPlay(false);}; 
            callLiarBtn.onclick=()=>{if(confirm("Are you sure you want to call LIAR!? This cannot be undone.")){if(localPlayer.isHost)handleHostPlayerCallLiar(localPlayer.id);else sendMessage('PLAYER_ACTION_CALL_LIAR',{});}}; 
            continueGameBtn.onclick=()=>{toggleModal(challengeRouletteOverlay,false);if(gameState.gamePhase==='game_over')toggleModal(gameOverOverlay,true);}; 
            
            playAgainBtn.onclick = () => {
                if (gameState.gamePhase !== 'game_over') return;
                localPlayer.readyForRematch = !localPlayer.readyForRematch;
                playAgainBtn.textContent = localPlayer.readyForRematch ? "Waiting for Others..." : "Ready for Rematch";
                playAgainBtn.style.backgroundColor = localPlayer.readyForRematch ? 'var(--accent-green)' : 'var(--accent-gold)';

                if (localPlayer.isHost) {
                    gameState.rematchReadyStatus[localPlayer.id] = localPlayer.readyForRematch;
                    updateRematchStatusDisplay(); // Host updates its own display immediately

                    const eligiblePlayers = getConnectedAndActivePlayerIds();
                    const allActuallyReady = eligiblePlayers.length > 0 &&
                                             eligiblePlayers.every(id => gameState.rematchReadyStatus[id] === true);

                    if (eligiblePlayers.length >= MIN_PLAYERS && allActuallyReady) {
                        addLogMessage("All players ready! Starting rematch...", "success");
                        initializeNewGame(); // This will broadcast the new game state
                    } else {
                        // Game not starting yet, or not enough players.
                        // Broadcast the current state of rematch readiness.
                        broadcastGameState();
                    }
                } else { // Client
                    sendMessage('PLAYER_TOGGLE_REMATCH_READY', { isReady: localPlayer.readyForRematch });
                }
            }; 

            exitGameBtn.onclick=()=>{if(localPlayer.isHost&&Object.keys(dataChannels).length>0)sendMessage('HOST_DISCONNECTED',{message:"Host ended game and exited."});addLogMessage("Exiting game to setup screen.", "system");showConnectionSetup();}; 
            document.addEventListener('keydown',e=>{const modalVis=Array.from(document.querySelectorAll('.modal')).some(m=>m.classList.contains('visible'));const inputFoc=['INPUT','TEXTAREA'].includes(document.activeElement.tagName);if(modalVis||inputFoc||connectionSetupDiv.style.display!=='none')return;if(e.key.toUpperCase()==='P'&&!playCardsBtn.disabled&&playConfirmArea.style.display==='none'){e.preventDefault();playCardsBtn.click();}if(e.key.toUpperCase()==='L'&&!callLiarBtn.disabled&&playConfirmArea.style.display==='none'){e.preventDefault();callLiarBtn.click();}}); 
            
            const debouncedRender = debounce(updateFullUI, 250);
            window.addEventListener('resize', debouncedRender);
            
            window.addEventListener('beforeunload',()=>{if(localPlayer.isHost&&gameState.gamePhase!=='lobby'&&Object.keys(dataChannels).length>0)sendMessage('HOST_DISCONNECTED',{message:"Host has left the page."});Object.values(peerConnections).forEach(pc=>{if(pc?.close)pc.close();});if(clientToServerPc?.close)clientToServerPc.close();}); 
            showConnectionSetup(); 
            logDebug("E-Money's Bar initialized.");
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>