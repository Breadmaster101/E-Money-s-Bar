<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Money's Bar 1.2</title>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary-bg: #1A222C; 
            --secondary-bg: #273440; 
            --tertiary-bg: #11171E; 
            --primary-text: #E0E6EB; 
            --secondary-text: #A0AEC0; 

            --accent-gold: #CFAF7B; 
            --accent-gold-darker: #B08F5F; 
            --accent-red: #E53E3E; 
            --accent-red-darker: #C53030; 
            --accent-green: #48BB78; 
            --accent-green-darker: #38A169; 
            --accent-highlight: #F6E05E; 

            --table-green: #2A4B3A; 
            --table-green-light: #3A6B4A; 
            
            --font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-family-serif: 'Merriweather', serif;
            --border-radius: 6px; 
            --box-shadow: 0 5px 15px rgba(0,0,0,0.35);
            --box-shadow-light: 0 3px 8px rgba(0,0,0,0.25);

            --input-bg: #D1D5DB; 
            --input-text: #1A222C; 
            --input-border: #6B7280; 

            --card-bg: #FEFDFB; 
            --card-border: #D1C7B7; 
            --card-selected-glow:  0 0 15px 4px var(--accent-gold); 
            
            --suit-red: var(--accent-red); 
            --suit-black: #2D3748; 

            --card-back-bg: #4A3B30; 
            --card-back-border: #30261F; 
            --card-back-motif: var(--accent-gold);
        }

        /* General Styles */
        body { 
            font-family: var(--font-family); 
            margin: 0; 
            padding: 0; 
            background-color: var(--tertiary-bg); 
            color: var(--primary-text); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            overflow: hidden; 
            background-image: 
                radial-gradient(circle at top left, rgba(255,255,255,0.03), transparent 40%),
                radial-gradient(circle at bottom right, rgba(255,255,255,0.03), transparent 40%);
        }
        #app-container { 
            width: 100vw; 
            height: 100vh; 
            max-width: none; 
            max-height: none; 
            border-radius: 0; 
            display: flex; 
            flex-direction: column; 
            background-color: var(--primary-bg); 
            box-shadow: none; 
            overflow: hidden; 
        }
        button { 
            padding: 12px 24px; 
            font-size: 1em; 
            font-weight: 600; 
            background-color: var(--accent-gold); 
            color: var(--primary-bg); 
            border: none; 
            border-radius: var(--border-radius); 
            cursor: pointer; 
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 -2px 0px rgba(0,0,0,0.15);
            text-transform: uppercase; 
            letter-spacing: 0.8px; 
            font-family: var(--font-family);
        }
        button:hover { 
            background-color: var(--accent-gold-darker); 
            transform: translateY(-2px); 
            box-shadow: 0 4px 8px rgba(0,0,0,0.25), inset 0 -1px 0px rgba(0,0,0,0.1); 
        }
        button:active { 
            transform: translateY(0px); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.2), inset 0 -1px 0px rgba(0,0,0,0.1); 
        }
        button:disabled { 
            background-color: #546e7a; 
            color: #90a4ae; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: inset 0 -2px 0px rgba(0,0,0,0.1); 
        }
        /* Base Textarea, Input - for non-copy-button ones */
        textarea, input[type="text"], input[type="number"], select { 
            width: calc(100% - 24px); 
            max-width: 500px; 
            margin: 10px auto; /* Centering */
            padding: 12px; 
            border-radius: var(--border-radius); 
            border: 1px solid var(--input-border); 
            background-color: var(--input-bg); 
            color: var(--input-text); 
            font-size: 1em; 
            box-sizing: border-box; 
            transition: border-color 0.2s ease, box-shadow 0.2s ease; 
            font-family: var(--font-family);
        }
        textarea { min-height: 80px; resize: vertical; }
        input:focus, textarea:focus, select:focus { 
            outline: none; 
            border-color: var(--accent-gold); 
            box-shadow: 0 0 0 3px rgba(207, 175, 123, 0.4); 
        }

        /* Modal styles */
        .modal { position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(17, 23, 30, 0.85); display: flex; justify-content: center; align-items: center; backdrop-filter: blur(6px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content { 
            background-color: var(--secondary-bg); 
            padding: 35px 40px; 
            border: 2px solid var(--accent-gold-darker); 
            width: 90%; max-width: 600px; 
            border-radius: var(--border-radius); 
            box-shadow: var(--box-shadow), 0 0 0 6px var(--primary-bg); 
            text-align: center; 
            transform: scale(0.95); 
            transition: transform 0.3s ease; 
            color: var(--primary-text);
        }
        .modal.visible .modal-content { transform: scale(1); }
        .modal-content h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            color: var(--accent-highlight); 
            font-size: 2.2em; 
            font-weight: 700; 
            font-family: var(--font-family-serif);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .modal-content button { margin: 15px 8px 0; }

        /* Connection Setup Screen */
        #connection-setup { padding: 35px; text-align: center; overflow-y: auto; height: 100%; display: flex; flex-direction: column; align-items: center; background-color: var(--primary-bg); }
        #connection-setup h2 { color: var(--primary-text); margin-bottom: 30px; font-size: 2.8em; font-weight: 700; font-family: var(--font-family-serif); text-shadow: 1px 1px 3px rgba(0,0,0,0.3); }
        #connection-setup > div:first-of-type { margin-bottom: 20px; } /* Button group container */
        .setup-section { background-color: var(--secondary-bg); padding: 30px; margin-top: 30px; border-radius: var(--border-radius); box-shadow: inset 0 3px 6px rgba(0,0,0,0.2), var(--box-shadow-light); width: 100%; max-width: 750px; box-sizing: border-box; border: 1px solid var(--tertiary-bg); }
        .setup-section h3 { color: var(--accent-gold); margin-top: 0; margin-bottom: 25px; font-size: 1.8em; border-bottom: 2px solid var(--accent-gold-darker); padding-bottom: 12px; font-family: var(--font-family-serif); }
        #host-controls p, #client-controls p { margin: 12px 0; font-size: 1.1em; color: var(--secondary-text); }
        #host-controls p strong, #client-controls p strong { color: var(--primary-text); }
        #connected-players-list { margin-top: 15px; font-weight: normal; text-align: left; padding-left: 10px; }
        #connected-players-list span { display: block; margin-bottom: 6px; padding: 8px 10px; background-color: rgba(255,255,255,0.05); border-radius: 4px; border-left: 3px solid var(--accent-gold); }
        #startGameBtn { background-color: var(--accent-green); color: white; margin-top: 25px; padding: 15px 30px; font-size: 1.2em;}
        #startGameBtn:hover { background-color: var(--accent-green-darker); }
        
        .room-code-container {
            display: flex;
            align-items: center;
            justify-content: center; 
            gap: 10px;
            margin: 15px auto;
            max-width: 90%;
        }
        #roomCodeDisplay { 
            flex-grow: 1;
            background-color: var(--primary-bg); 
            padding: 15px 20px; 
            border-radius: var(--border-radius); 
            border: 2px solid var(--accent-gold);
            word-break: break-all;
            font-size: 1.1em;
            font-weight: bold;
            color: var(--accent-highlight);
            text-align: left;
        }
        .copy-btn-beside {
            padding: 10px 15px; 
            font-size: 1em;  
            background-color: var(--secondary-text);
            color: var(--primary-bg);
            border-radius: var(--border-radius);
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: auto; 
            width: auto;
            text-transform: uppercase; 
            letter-spacing: 0.8px; 
            font-weight: 600; 
        }
        .copy-btn-beside:hover {
            background-color: var(--accent-gold);
        }
        .copy-btn-beside:disabled { 
            background-color: var(--accent-green-darker);
            color: white;
            cursor: default;
        }


        #client-status { margin-top: 20px; font-weight: bold; font-size: 1.1em; padding: 10px; border-radius: var(--border-radius); background-color: rgba(0,0,0,0.1); }
        #connectToHostBtn { margin-top: 15px; } 
        
        /* Debug Log styles */
        #debug-log { margin-top: 35px; background: var(--tertiary-bg); padding: 18px; border-radius: var(--border-radius); max-height: 180px; overflow-y: auto; font-size: 0.9em; text-align: left; width: 100%; max-width: 750px; box-sizing: border-box; border: 1px solid #4a6075; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); margin-left: auto; margin-right: auto; }
        #debug-log strong { color: var(--accent-highlight); display: block; margin-bottom: 8px; font-size: 1.1em; font-family: var(--font-family-serif); }
        #debug-log p { margin: 3px 0; line-height: 1.5; color: var(--secondary-text); }
        #debug-log p:nth-child(odd) { background-color: rgba(255,255,255,0.03); }

        /* Game Board */
        #game-board { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            background-color: var(--table-green); 
            background-image: 
                radial-gradient(ellipse at center, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.0) 70%),
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.07'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); 
            position: relative; 
            overflow: hidden; 
            padding: 20px; 
            box-sizing: border-box; 
        }
        #player-areas-container { 
            position: relative; 
            flex-grow: 1;      
            width: 100%;      
            height: 100%;     
        }
        .player-area { 
            position: absolute; 
            background-color: rgba(26, 34, 44, 0.85); 
            padding: 10px 15px; 
            border-radius: var(--border-radius); 
            text-align: center; 
            min-width: 170px; 
            max-width: 200px; 
            box-shadow: var(--box-shadow), 0 0 0 2px rgba(0,0,0,0.2); 
            border: 2px solid var(--tertiary-bg); 
            transition: transform 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease, opacity 0.4s ease; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            transform-origin: center center;
            box-sizing: border-box; 
        }
        .player-area.current-player { 
            border-color: var(--accent-highlight); 
            z-index: 10; 
            animation: pulsePlayer 1.8s infinite ease-in-out; 
        }
        @keyframes pulsePlayer { 
            0% { 
                box-shadow: 0 0 25px 0px var(--accent-highlight), 0 0 35px 6px rgba(246, 224, 94, 0.55), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.03); 
            } 
            50% { 
                box-shadow: 0 0 30px 4px var(--accent-highlight), 0 0 45px 10px rgba(246, 224, 94, 0.65), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.05); 
            } 
            100% { 
                box-shadow: 0 0 25px 0px var(--accent-highlight), 0 0 35px 6px rgba(246, 224, 94, 0.55), 0 0 0 2px rgba(0,0,0,0.2); 
                transform: translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)) scale(1.03); 
            } 
        }

        .player-area.eliminated { opacity: 0.5; filter: grayscale(100%); border-color: var(--secondary-text) !important; box-shadow: none !important; animation: none !important; transform: scale(0.95) translateX(var(--base-translate-x, 0%)) translateY(var(--base-translate-y, 0%)) rotate(var(--base-rotate, 0deg)); }
        .player-name { font-weight: bold; font-size: 1.1em; margin-bottom: 4px; color: var(--primary-text); line-height: 1.2; font-family: var(--font-family-serif); }
        .player-avatar { font-size: 2.1em; margin-bottom: 5px; line-height: 1; color: var(--accent-gold); }

        .player-card-visuals {
            position: relative; 
            height: 40px; 
            width: 80px; 
            margin: 2px auto 3px;
            display: flex;
            justify-content: center;
            align-items: flex-end; 
        }
        .player-area-mini-card { 
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4));
        }
        .player-area-mini-card svg { 
            width: 22px !important; 
            height: 33px !important; 
        }
        .player-area-mini-card svg rect[stroke="var(--card-back-border)"] { stroke-width: 0.5px; }
        .player-area-mini-card svg rect[x="3.5"] { display: none; } 
        .player-area-mini-card svg text { font-size: 16px !important; }

        .player-revolver-visuals {
            position: relative; 
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 4px;
            gap: 3px;
        }
        .revolver-chamber {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            border: 1px solid var(--accent-gold-darker);
            transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
        }
        .revolver-chamber.available {
            background-color: var(--accent-gold); 
        }
        .revolver-chamber.fired {
            background-color: var(--tertiary-bg); 
            opacity: 0.6;
        }
        
        .has-tooltip {
            cursor: default; 
        }
        .has-tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%; 
            left: 50%;
            transform: translateX(-50%) translateY(-5px); 
            background-color: var(--tertiary-bg);
            color: var(--primary-text);
            padding: 4px 7px; 
            border-radius: 4px;
            font-size: 0.7em; 
            font-family: var(--font-family);
            white-space: nowrap; 
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease 0.1s, visibility 0s linear 0.3s; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: none; 
        }
        .has-tooltip:hover::after {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.2s ease 0.1s;
        }

        #local-player-stats-area {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(26, 34, 44, 0.75);
            padding: 8px 12px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-light);
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }
        #local-player-stats-area .stat-label {
            font-size: 0.8em;
            color: var(--secondary-text);
            margin-bottom: 2px;
        }
        #local-player-stats-area .player-revolver-visuals {
            margin-top: 0; 
        }


        #center-table { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            display: flex; flex-direction: column; align-items: center; 
            padding: 20px; 
            background-color: rgba(17, 23, 30, 0.6); 
            border: 2px solid rgba(0,0,0,0.3); 
            border-radius: 12px; 
            min-width: 320px; 
            box-shadow: var(--box-shadow), inset 0 0 15px rgba(0,0,0,0.3); 
        }
        #center-pile-visual { width: 75px; height: 105px; margin-bottom: 12px; position: relative; }
        #center-pile-visual .card-stack { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #center-pile-visual .card-back-dummy { 
            position: absolute; 
            border-radius: 6px; 
            width: 60px; height: 90px; 
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }

        #table-type-display-area { margin-bottom: 10px; text-align: center; } 
        #table-type-display-area h4 { margin: 0 0 8px 0; font-size: 1em; color: var(--secondary-text); font-weight: 500; letter-spacing: 0.5px; }
        #table-type-card { 
            display: inline-flex; justify-content: center; align-items: center; 
            width: 60px; height: 90px; 
            background-color: var(--card-bg); 
            border: 1px solid var(--card-border); 
            border-radius: 6px; font-size: 48px; line-height: 1; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.15), inset 0 0 5px rgba(0,0,0,0.1);
            color: var(--primary-text); 
        }
        #played-cards-pile-info { 
            font-size: 1em; font-weight: bold; margin-bottom: 10px; 
            padding: 10px 15px; 
            background-color: rgba(0,0,0,0.25); 
            border-radius: var(--border-radius); 
            min-height: 22px; text-align: center; 
            color: var(--primary-text); 
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }

        #game-log { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 280px; max-width: 30%; max-height: 180px; z-index: 30; 
            background-color: rgba(210, 199, 183, 0.9); 
            color: #3A322E; 
            border-radius: var(--border-radius); 
            padding: 10px 15px; 
            border: 2px solid #A1887F; 
            box-shadow: var(--box-shadow-light); 
            font-family: var(--font-family-serif);
        }
        #game-log h4 { 
            margin: 0 0 8px 0; text-align: center; font-size: 1.05em; 
            color: #5D4037; 
            border-bottom: 1px solid #A1887F; 
            padding-bottom: 6px; font-weight: 700; 
        }
        #log-messages { 
            height: 110px; overflow-y: auto; font-size: 0.85em; 
            padding: 8px; border-radius: 4px; 
            background-color: rgba(0,0,0,0.05); 
            color: #4E342E;
        }
        #log-messages p { margin: 4px 0; line-height: 1.4; }
        #log-messages p.error { color: var(--accent-red-darker); font-weight: bold; }
        #log-messages p.system { color: #00695C; font-style: italic; } 
        #log-messages p.success { color: var(--accent-green-darker); font-weight: bold; }
        #log-messages::-webkit-scrollbar { width: 8px; } 
        #log-messages::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; } 
        #log-messages::-webkit-scrollbar-thumb { background: #8D6E63; border-radius: 4px; } 
        #log-messages::-webkit-scrollbar-thumb:hover { background: #795548; }

        #player-hand-area { 
            position: absolute; bottom: 20px; left: 50%; 
            transform: translateX(-50%); 
            display: flex; gap: 8px; 
            padding: 10px; 
            background-color: rgba(17, 23, 30, 0.5); 
            border-radius: var(--border-radius); 
            z-index: 20; 
            box-shadow: var(--box-shadow), 0 0 0 2px rgba(0,0,0,0.15); 
            transition: box-shadow 0.3s ease, border-color 0.3s ease; 
            border-top: 2px solid rgba(255,255,255,0.05);
        }
        #player-hand-area.current-player-hand { 
            border-top-color: var(--accent-highlight);
            box-shadow: 
                0 0 20px 5px var(--accent-highlight), 
                inset 0 -2px 0 0 var(--accent-highlight), 
                inset -2px 0 0 0 var(--accent-highlight), 
                inset 2px 0 0 0 var(--accent-highlight),  
                0 0 0 2px rgba(0,0,0,0.15); 
        }
        #player-hand-area.card-selection-active { 
            border-top-color: var(--accent-gold);
            box-shadow: 
                0 0 18px 6px var(--accent-gold), 
                inset 0 -2px 0 0 var(--accent-gold), 
                inset -2px 0 0 0 var(--accent-gold), 
                inset 2px 0 0 0 var(--accent-gold), 
                0 0 0 2px rgba(0,0,0,0.15); 
        } 
        #player-hand-area.card-selection-active .card-container { cursor: pointer; opacity: 0.75; filter: saturate(0.7); }
        #player-hand-area.card-selection-active .card-container.selected-for-play { opacity: 1; transform: translateY(-18px) scale(1.12); filter: saturate(1); }
        #player-hand-area.card-selection-active .card-container.selected-for-play svg { box-shadow: var(--card-selected-glow); }

        .card-container { display: inline-block; perspective: 1000px; transition: opacity 0.2s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .card-container svg { display: block; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); border-radius: 6px; }
        
        #player-hand-area > .card-container:not(.selected-for-play):hover svg { 
            transform: translateY(-18px) scale(1.12) rotateX(8deg); 
            box-shadow: 0 10px 20px rgba(0,0,0,0.25); 
        }
        #player-hand-area > .card-container.selected-for-play svg { 
            transform: translateY(-12px) scale(1.08); 
            box-shadow: var(--card-selected-glow); 
        }


        #play-confirm-area { 
            position: absolute; bottom: 110px; 
            left: 50%; transform: translateX(-50%); 
            padding: 12px 18px; 
            background-color: rgba(39, 52, 64, 0.95); 
            border-radius: var(--border-radius); 
            box-shadow: var(--box-shadow); 
            z-index: 22; text-align: center; 
            border: 1px solid var(--tertiary-bg);
        }
        #play-confirm-area p { margin:0 0 12px 0; font-size: 0.95em; color: var(--primary-text); }
        #actions-area { 
            position: absolute; bottom: 25px; right: 25px; 
            display: flex; flex-direction: column; gap: 12px; z-index: 25; 
        }
        #actions-area button { 
            width: 170px; padding: 14px 18px; font-size: 1em; letter-spacing: 0.6px;
        }
        #playCardsBtn { background-color: var(--accent-green); color: white; } 
        #playCardsBtn:hover { background-color: var(--accent-green-darker); }
        #callLiarBtn { background-color: var(--accent-red); color: white; } 
        #callLiarBtn:hover { background-color: var(--accent-red-darker); }
        #confirmPlayBtn { background-color: var(--accent-green); color: white; }
        #cancelPlayBtn { background-color: var(--secondary-text); color: var(--primary-bg); }
        #cancelPlayBtn:hover { background-color: #BCC1C6; }


        #challenge-roulette-overlay .modal-content { max-width: 700px; padding: 40px; }
        #challenge-roulette-overlay #revealed-cards-display { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0; padding: 12px; background-color: rgba(0,0,0,0.2); border-radius: var(--border-radius); border: 1px solid rgba(0,0,0,0.1); }
        #challenge-roulette-overlay #roulette-result-text { font-weight:bold; font-size: 1.4em; margin: 20px 0; letter-spacing: 0.5px; }
        #challenge-roulette-overlay #roulette-animation { font-size: 2.2em; margin: 15px; min-height: 50px; display: flex; justify-content: center; align-items: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        #roulette-animation.spinning span { display: inline-block; animation: spin 0.5s linear infinite, symbolPulse 0.25s alternate infinite ease-in-out; }
        @keyframes spin { 0% { transform: rotate(0deg) scale(1); } 100% { transform: rotate(360deg) scale(1); } }
        @keyframes symbolPulse { 0% { transform: scale(0.9); opacity: 0.8; } 100% { transform: scale(1.1); opacity: 1;} }
        
        #game-over-overlay .modal-content { max-width: 520px; }
        #gameOverTitle { color: var(--accent-highlight); font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.4); }
        #gameOverMessageP { font-size: 1.25em; margin-bottom: 20px; line-height: 1.5; } 
        #rematch-status-container { margin-top: 15px; text-align: left; font-size: 0.9em;}
        #rematch-status-container h4 { margin-bottom: 8px; color: var(--accent-gold); font-size: 1.1em; }
        #rematch-status-list span { display: block; margin-bottom: 4px; padding: 3px 6px; background-color: rgba(255,255,255,0.03); border-radius: 3px;}
        #rematch-status-list .ready { color: var(--accent-green); font-weight: bold; }
        #rematch-status-list .not-ready { color: var(--secondary-text); }

        #playAgainBtn { background-color: var(--accent-gold); color: var(--primary-bg); } 
        #playAgainBtn:hover { background-color: var(--accent-gold-darker); }
        #exitGameBtn { background-color: var(--secondary-text); color: var(--primary-bg); } 
        #exitGameBtn:hover { background-color: #95a5a6; }

        /* Responsive Adjustments */
        @media (max-width: 1200px) { 
            .player-area { min-width: 160px; padding: 10px 15px;} 
            #game-log { width: 240px; max-height: 160px; } 
            #local-player-stats-area { top: 15px; left: 15px; padding: 6px 10px;}
        }
        @media (max-width: 768px) { 
            body { font-size: 14px; } 
            .player-area { padding: 8px 10px; min-width: 110px !important; width: auto !important; } 
            .player-area .player-name { font-size: 0.8em; } 
            .player-area .player-avatar { font-size: 1.5em; margin-bottom: 4px;} 
            #center-table { min-width: 80%; padding: 12px; } 
            #center-pile-visual { width: 55px; height: 80px; margin-bottom: 6px;} 
            #center-pile-visual .card-back-dummy { width: 50px; height: 75px; }
            #table-type-display-area { margin-bottom: 8px;} 
            #table-type-card { font-size: 32px; width: 50px; height:75px; } 
            #played-cards-pile-info { font-size: 0.85em; padding: 8px 10px;} 
            #game-log { bottom: auto; top: 100px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 300px; max-height: 70px; padding: 8px; font-size: 0.9em; } 
            #log-messages { height: 35px; font-size: 0.78em; } 
            #player-hand-area { bottom: 85px; max-width: 95%; gap: 4px; padding: 8px; } 
            .card-container svg { width: 45px; height: 68px;} 
            #play-confirm-area { bottom: 165px; width: 90%; padding: 10px;} 
            #actions-area { flex-direction: row; bottom: 15px; left: 50%; transform: translateX(-50%); width: 95%; justify-content: space-around; gap: 8px; } 
            #actions-area button { width: auto; flex-grow: 1; padding: 12px 10px; font-size: 0.9em; } 
            
            .player-card-visuals { height: 35px; width: 60px; } 
            .player-area-mini-card svg { width: 20px !important; height: 30px !important; }
            .revolver-chamber { width: 8px !important; height: 8px !important; }
            #local-player-stats-area { top: 10px; left: 10px; padding: 5px 8px; gap: 3px;}
            #local-player-stats-area .stat-label { font-size: 0.7em; }
            #game-log { top: 65px; max-height: 60px; } 
            #log-messages { height: 25px; }
        }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="connection-setup">
            <h2>E-Money's Bar 1.2</h2>
            <input type="text" id="playerNameInput" placeholder="Enter Your Name (Min 3 chars)" value="">
            <div>
                <button id="createRoomBtn">Create Room</button>
                <button id="joinRoomBtn">Join Room</button>
            </div>

            <div id="host-controls" class="setup-section" style="display:none;">
                <h3>Host Controls</h3>
                <p>Your Room Code is (share with players):</p>
                <div class="room-code-container">
                    <span id="roomCodeDisplay">Waiting for Room Code...</span>
                    <button id="copyRoomCodeBtn" class="copy-btn-beside" title="Copy Room Code">COPY</button>
                </div>
                <p><strong>Connected Players:</strong> <span id="connected-players-count">0 / 3</span></p>
                <div id="connected-players-list"></div>
                <button id="startGameBtn" disabled>Start Game (2-4 Players)</button>
            </div>

            <div id="client-controls" class="setup-section" style="display:none;">
                <h3>Join Room</h3>
                <input type="text" id="roomCodeInput" placeholder="Enter Host's Room Code">
                <button id="connectToHostBtn">Connect to Host</button>
                <p id="client-status">Enter your name above, then the Room Code from the host and click "Connect to Host".</p>
            </div>
             <div id="debug-log"><strong>Debug Log:</strong></div>
        </div>

        <div id="game-board" style="display:none;">
            <div id="local-player-stats-area" style="display:none;">
                <span class="stat-label">My Revolver:</span>
                <div id="local-revolver-visuals" class="player-revolver-visuals has-tooltip"></div>
            </div>
            <div id="player-areas-container"></div>
            <div id="center-table">
                <div id="center-pile-visual"><div class="card-stack"></div></div>
                <div id="table-type-display-area">
                    <h4>Table Suit:</h4>
                    <div id="table-type-card"></div> 
                </div>
                <div id="played-cards-pile-info">Played this turn: 0 cards</div>
            </div>
            <div id="game-log"><h4>Game Log</h4><div id="log-messages"></div></div>
            <div id="play-confirm-area" style="display:none;">
                <p id="play-confirm-text">Play 0 cards as X?</p>
                <button id="confirmPlayBtn">Confirm</button>
                <button id="cancelPlayBtn">Cancel</button>
            </div>
            <div id="player-hand-area"></div>
            <div id="actions-area">
                <button id="playCardsBtn" disabled>Play Cards</button>
                <button id="callLiarBtn" disabled>"LIAR!"</button>
            </div>
        </div>

        <div id="challenge-roulette-overlay" class="modal">
            <div class="modal-content">
                <h3 id="challenge-roulette-title">Challenge Result!</h3>
                <p id="challenge-roulette-details"></p> 
                <div id="revealed-cards-display"></div>
                <p id="challenge-roulette-consequence"></p> 
                <div id="roulette-animation"></div> 
                <p id="roulette-result-text"></p> 
                <button id="continueGameBtn">Continue</button>
            </div>
        </div>

        <div id="game-over-overlay" class="modal">
            <div class="modal-content">
                <h3 id="gameOverTitle">Game Over!</h3>
                <p id="gameOverMessageP"></p>
                <div id="rematch-status-container" style="display:none;">
                    <h4>Rematch Status:</h4>
                    <div id="rematch-status-list"></div>
                </div>
                <div>
                    <button id="playAgainBtn">Ready for Rematch</button>
                    <button id="exitGameBtn">Exit to Setup</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const MAX_PLAYERS = 4;
        const MIN_PLAYERS = 2;
        const HAND_SIZE = 5; 
        
        const SUITS = ['H', 'D', 'C', 'S']; 
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const SUIT_SYMBOLS = {'H': 'â™¥', 'D': 'â™¦', 'C': 'â™£', 'S': 'â™ '};
        const SUIT_COLORS = {'H': 'var(--suit-red)', 'D': 'var(--suit-red)', 'C': 'var(--suit-black)', 'S': 'var(--suit-black)'};

        const REVOLVER_CHAMBERS = 6;
        const REVOLVER_BULLETS = 1;

        const $ = (s) => document.querySelector(s);
        const appContainer = $('#app-container'); const connectionSetupDiv = $('#connection-setup'); const gameBoardDiv = $('#game-board');
        const playerNameInput = $('#playerNameInput'); const createRoomBtn = $('#createRoomBtn'); const joinRoomBtn = $('#joinRoomBtn');
        const hostControlsDiv = $('#host-controls'); const roomCodeDisplay = $('#roomCodeDisplay'); const copyRoomCodeBtn = $('#copyRoomCodeBtn');
        const connectedPlayersCountSpan = $('#connected-players-count'); const connectedPlayersListDiv = $('#connected-players-list'); const startGameBtn = $('#startGameBtn');
        const clientControlsDiv = $('#client-controls'); const roomCodeInput = $('#roomCodeInput'); const connectToHostBtn = $('#connectToHostBtn');
        const clientStatusP = $('#client-status');
        const debugLogDiv = $('#debug-log');
        const playerAreasContainer = $('#player-areas-container');
        const centerPileVisualStack = $('#center-pile-visual .card-stack');
        const tableTypeCardDiv = $('#table-type-card'); 
        const playedCardsPileInfo = $('#played-cards-pile-info');
        const logMessagesDiv = $('#log-messages');
        const localPlayerStatsArea = $('#local-player-stats-area');
        const localRevolverVisuals = $('#local-revolver-visuals');
        const playerHandArea = $('#player-hand-area');
        const playConfirmArea = $('#play-confirm-area');
        const playConfirmText = $('#play-confirm-text');
        const confirmPlayBtn = $('#confirmPlayBtn');
        const cancelPlayBtn = $('#cancelPlayBtn');
        const playCardsBtn = $('#playCardsBtn'); 
        const callLiarBtn = $('#callLiarBtn');   
        const challengeRouletteOverlay = $('#challenge-roulette-overlay');
        const challengeRouletteTitle = $('#challenge-roulette-title');
        const challengeRouletteDetailsP = $('#challenge-roulette-details');
        const revealedCardsDisplay = $('#revealed-cards-display'); 
        const challengeRouletteConsequenceP = $('#challenge-roulette-consequence');
        const rouletteAnimationDiv = $('#roulette-animation');
        const rouletteResultTextP = $('#roulette-result-text');
        const continueGameBtn = $('#continueGameBtn'); 
        const gameOverOverlay = $('#game-over-overlay');
        const gameOverTitle = $('#gameOverTitle'); const gameOverMessageP = $('#gameOverMessageP');
        const rematchStatusContainer = $('#rematch-status-container');
        const rematchStatusListDiv = $('#rematch-status-list');
        const playAgainBtn = $('#playAgainBtn'); const exitGameBtn = $('#exitGameBtn');
        
        let localPlayer = { id: null, name: "", peer: null, isHost: false, hand: [], eliminated: false, revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0, readyForRematch: false };
        let gameState = { players: [], liarsDeck: [], tableDeck: [], centerPile: [], currentPlayerId: null, currentTableSuit: null, lastPlayedTurn: null, gamePhase: 'lobby', config: { handSize: HAND_SIZE }, centerPileCardCount: 0, rematchReadyStatus: {} };
        
        let hostConnections = {}; 
        let clientConnectionToHost = null; 

        let selectedCardsForPlayUI = []; 
        let lastLoggedGameStateForClient = {}; 
        let rouletteSymbolInterval = null;

        function copyToClipboard(text, buttonElement) {
            if (!text || text.trim() === "" || text.startsWith("Waiting")) {
                alert("No valid content to copy yet.");
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                if (buttonElement) {
                    const originalText = buttonElement.textContent; 
                    const originalTitle = buttonElement.title;
                    buttonElement.textContent = 'Copied!'; 
                    buttonElement.title = 'Copied!';
                    buttonElement.disabled = true;
                    setTimeout(() => {
                        buttonElement.textContent = originalText; 
                        buttonElement.title = originalTitle;
                        buttonElement.disabled = false;
                    }, 1500);
                }
                logDebug('Content copied to clipboard.');
            }).catch(err => {
                logDebug('Could not copy text: ', err);
                alert('Failed to copy text.');
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function toggleModal(modalElement, show) { if (show) { modalElement.style.display = 'flex'; setTimeout(() => modalElement.classList.add('visible'), 10); } else { modalElement.classList.remove('visible'); setTimeout(() => modalElement.style.display = 'none', 300);}}
        function logDebug(message) { console.log(message); const p = document.createElement('p'); p.textContent = `[${new Date().toLocaleTimeString()}] ${typeof message === 'object' ? JSON.stringify(message) : message}`; debugLogDiv.appendChild(p); debugLogDiv.scrollTop = debugLogDiv.scrollHeight; }
        
        function addLogMessage(message, type = "info") { 
            const p = document.createElement('p'); 
            p.textContent = message; 
            if (type === "error") p.classList.add('error');
            else if (type === "system") p.classList.add('system');
            else if (type === "success") p.classList.add('success');
            
            if (logMessagesDiv) { 
                logMessagesDiv.appendChild(p); 
                logMessagesDiv.scrollTop = logMessagesDiv.scrollHeight; 
            } else console.warn("Log div not ready:", message); 
        }


        function createCardElement(rank, suit, faceUp = true, isSmall = false) {
            const cc = document.createElement('div'); cc.className = 'card-container'; const cardId = `${rank}${suit}`;
            const w = isSmall ? (window.innerWidth <= 768 ? 45 : 50) : 60;
            const h = isSmall ? (window.innerWidth <= 768 ? 68 : 75) : 90;
            let svg;
            if (!faceUp) { 
                svg = `<svg width="${w}" height="${h}" viewBox="0 0 60 90" class="card back" preserveAspectRatio="xMidYMid meet">
                    <rect x="0.5" y="0.5" width="59" height="89" rx="5.5" ry="5.5" fill="var(--card-back-bg)" stroke="var(--card-back-border)" stroke-width="1"/>
                    <rect x="3.5" y="3.5" width="53" height="83" rx="2.5" ry="2.5" fill="none" stroke="var(--card-back-motif)" stroke-width="1.5" opacity="0.7"/>
                    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--card-back-motif)" font-size="40" font-family="'Merriweather', serif" font-weight="bold" opacity="0.85">L</text>
                </svg>`;
            } 
            else { const rankDisplay = rank === '10' ? '10' : rank.charAt(0); const suitSymbol = SUIT_SYMBOLS[suit] || suit; const color = SUIT_COLORS[suit] || 'var(--primary-text)';
                svg = `<svg width="${w}" height="${h}" viewBox="0 0 60 90" class="card" preserveAspectRatio="xMidYMid meet">
                    <defs><filter id="cardDropShadowInternal_${cardId.replace(/[^a-zA-Z0-9]/g, '')}" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur in="SourceAlpha" stdDeviation="0.5"/><feOffset dx="0.5" dy="0.5" result="offsetblur"/><feFlood flood-color="rgba(0,0,0,0.15)"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>
                    <rect x="0.5" y="0.5" width="59" height="89" rx="5.5" ry="5.5" fill="var(--card-bg)" stroke="var(--card-border)" stroke-width="1" filter="url(#cardDropShadowInternal_${cardId.replace(/[^a-zA-Z0-9]/g, '')})"/>
                    <text x="7" y="17" font-family="var(--font-family)" font-size="${rank === '10' ? '12' : '14'}" font-weight="700" fill="${color}">${rankDisplay}</text>
                    <text x="7" y="31" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="11" fill="${color}">${suitSymbol}</text>
                    <text x="50%" y="58%" dominant-baseline="middle" text-anchor="middle" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="36" fill="${color}">${suitSymbol}</text>
                    <g transform="rotate(180 30 45)"><text x="7" y="17" font-family="var(--font-family)" font-size="${rank === '10' ? '12' : '14'}" font-weight="700" fill="${color}">${rankDisplay}</text><text x="7" y="31" font-family="'Segoe UI Symbol', Arial, sans-serif" font-size="11" fill="${color}">${suitSymbol}</text></g>
                </svg>`;}
            cc.innerHTML = svg; cc.dataset.cardId = cardId; cc.dataset.rank = rank; cc.dataset.suit = suit; return cc;
        }

        function renderPlayerHand() { playerHandArea.innerHTML = ''; localPlayer.hand.sort((a, b) => { const sO={'H':0,'D':1,'C':2,'S':3}; if(sO[a.suit]!==sO[b.suit])return sO[a.suit]-sO[b.suit]; const rV=r=>RANKS.indexOf(r); return rV(a.rank)-rV(b.rank);}).forEach(card => { playerHandArea.appendChild(createCardElement(card.rank, card.suit, true)); });}
        
        function renderPlayerAreas() {
            playerAreasContainer.innerHTML = '';
            const orderedPlayers = [...gameState.players];
            if (orderedPlayers.length === 0) return;

            const localPIndexInOrdered = orderedPlayers.findIndex(p => p.id === localPlayer.id);
            let viewPlayers = [...orderedPlayers];
            if (localPIndexInOrdered !== -1) {
                viewPlayers = [...orderedPlayers.slice(localPIndexInOrdered), ...orderedPlayers.slice(0, localPIndexInOrdered)];
            } else if (gameState.gamePhase !== 'lobby') {
                logDebug("CRITICAL: Local player not found for layout."); return;
            }

            const opponents = viewPlayers.filter(p => p.id !== localPlayer.id);
            const numOpponents = opponents.length;

            if (numOpponents === 0 && gameState.players.length <=1) return; 

            const gameBoardPadding = parseFloat(getComputedStyle(gameBoardDiv).paddingTop) || 20; 
            let playerAreaWidthEstimate = 200; 
            let playerAreaHeightEstimate = 140; 

            const tempPlayerAreaForEstimates = document.createElement('div');
            tempPlayerAreaForEstimates.className = 'player-area';
            tempPlayerAreaForEstimates.style.visibility = 'hidden';
            tempPlayerAreaForEstimates.style.position = 'absolute'; 
            playerAreasContainer.appendChild(tempPlayerAreaForEstimates);
            playerAreaWidthEstimate = tempPlayerAreaForEstimates.offsetWidth || 200;
            playerAreaHeightEstimate = tempPlayerAreaForEstimates.offsetHeight || 140;
            playerAreasContainer.removeChild(tempPlayerAreaForEstimates);


            const centerTableEl = $('#center-table');
            if (!gameBoardDiv || !centerTableEl) {
                logDebug("Board or center table not found for dynamic positioning - using fallback.");
                const fallbackPositions = window.innerWidth <= 768 ? 
                    [ { top: '4%', left: '50%', translateX: '-50%', translateY: '-50%'}, { top: '30%', left: '10%', translateX: '0%', translateY: '-50%'}, { top: '30%', right: '10%', translateX: '0%', translateY: '-50%'} ] : 
                    [ { top: '4%', left: '50%', translateX: '-50%', translateY: '-50%'}, { top: '50%', left: '15%', translateX: '0%', translateY: '-50%'}, { top: '50%', right: '15%', translateX: '0%', translateY: '-50%'} ]; 
                
                opponents.forEach((opponent, idx) => {
                    const pa = document.createElement('div');
                    pa.className = 'player-area';
                    pa.dataset.playerId = opponent.id;
                    let layoutData = fallbackPositions[idx % fallbackPositions.length] || { top: `${10 + idx * 15}%`, left: '10%'};
                    Object.assign(pa.style, layoutData);
                    pa.innerHTML = `<div class="player-avatar">${opponent.isHost ? 'ðŸ‘‘' : 'ðŸ‘¤'}</div><div class="player-name">${opponent.name}</div><span>Cards: ${opponent.cardCount}, Revolver: ${opponent.revolverChambersLeft}/${REVOLVER_CHAMBERS}</span>`;
                    playerAreasContainer.appendChild(pa);
                });
                return;
            }

            const gbRect = gameBoardDiv.getBoundingClientRect();
            const ctRect = centerTableEl.getBoundingClientRect();
            
            const containerContentTopYAbsolute = gbRect.top + gameBoardPadding; 
            const containerContentLeftXAbsolute = gbRect.left + gameBoardPadding;

            const zoneTopAbsoluteY = containerContentTopYAbsolute;
            const zoneBottomAbsoluteY = ctRect.top;
            const verticalZoneHeight = zoneBottomAbsoluteY - zoneTopAbsoluteY;

            let topPlayerCenterCssTopVal; 
            const MIN_TOP_EDGE_GAP = 15; 

            const idealCenterInZoneRelative = verticalZoneHeight / 2;
            const minCenterRequired = MIN_TOP_EDGE_GAP + (playerAreaHeightEstimate / 2);

            if (verticalZoneHeight < (playerAreaHeightEstimate + 2 * MIN_TOP_EDGE_GAP) ) {
                topPlayerCenterCssTopVal = minCenterRequired;
            } else {
                topPlayerCenterCssTopVal = idealCenterInZoneRelative;
                topPlayerCenterCssTopVal = Math.max(minCenterRequired, topPlayerCenterCssTopVal);
            }
            
            const actualTopGap = topPlayerCenterCssTopVal - (playerAreaHeightEstimate / 2);
            const MIN_SIDE_GAP = 20; 
            let sidePlayerHorizontalGap = Math.max(MIN_SIDE_GAP, actualTopGap);
            
            const ctLeftRel = ctRect.left - containerContentLeftXAbsolute;
            const ctRightRel = ctRect.right - containerContentLeftXAbsolute; 

            const layoutSlots = [];

            if (numOpponents === 1) { 
                layoutSlots.push({
                    top: `${topPlayerCenterCssTopVal}px`, left: '50%',
                    translateX: '-50%', translateY: '-50%', 
                    rotate: '0deg'
                });
            } else if (numOpponents === 2) { 
                // MODIFIED SECTION FOR 2 OPPONENTS
                // Slot for the left side
                layoutSlots.push({ 
                    top: `50%`, 
                    left: `${ctLeftRel - sidePlayerHorizontalGap - playerAreaWidthEstimate}px`,
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
                // Slot for the right side
                layoutSlots.push({ 
                    top: `50%`,
                    left: `${ctRightRel + sidePlayerHorizontalGap}px`, 
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
                // END OF MODIFIED SECTION
            } else if (numOpponents === 3) { 
                 layoutSlots.push({ 
                    top: `50%`,
                    left: `${ctLeftRel - sidePlayerHorizontalGap - playerAreaWidthEstimate}px`,
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
                layoutSlots.push({ 
                    top: `${topPlayerCenterCssTopVal}px`, left: '50%',
                    translateX: '-50%', translateY: '-50%', 
                    rotate: '0deg'
                });
                layoutSlots.push({ 
                    top: `50%`,
                    left: `${ctRightRel + sidePlayerHorizontalGap}px`, 
                    translateX: '0%', translateY: '-50%', 
                    rotate: '0deg'
                });
            }
            
            opponents.forEach((opponent, idx) => {
                if (idx >= layoutSlots.length) {
                    logDebug(`No dynamic layout slot for opponent index ${idx}.`);
                    return; 
                }
                const pa = document.createElement('div');
                pa.className = 'player-area';
                pa.dataset.playerId = opponent.id;
                
                const layoutData = layoutSlots[idx];
                
                pa.style.top = layoutData.top;
                pa.style.left = layoutData.left;

                const baseTX = layoutData.translateX || '0%';
                const baseTY = layoutData.translateY || '0%';
                const baseRot = layoutData.rotate || '0deg';

                pa.style.setProperty('--base-translate-x', baseTX);
                pa.style.setProperty('--base-translate-y', baseTY);
                pa.style.setProperty('--base-rotate', baseRot);
                pa.style.transform = `translateX(${baseTX}) translateY(${baseTY}) rotate(${baseRot})`;
                
                if (opponent.id === gameState.currentPlayerId) {
                    pa.classList.add('current-player'); 
                }
                
                if (opponent.eliminated) pa.classList.add('eliminated');

                const av = opponent.isHost ? 'ðŸ‘‘' : 'ðŸ‘¤';
                pa.innerHTML = `<div class="player-avatar">${av}</div><div class="player-name">${opponent.name}</div>`;

                const cardVisualsContainer = document.createElement('div');
                cardVisualsContainer.className = 'player-card-visuals has-tooltip';
                const actualCardCount = opponent.eliminated ? 0 : (opponent.cardCount !== undefined ? opponent.cardCount : 0);
                cardVisualsContainer.dataset.tooltip = `Cards: ${actualCardCount}`;
                const miniCardStep = 8; 

                if (actualCardCount > 0) {
                    const baseLeftOffset = (actualCardCount - 1) * -(miniCardStep / 2);
                    for (let i = 0; i < actualCardCount; i++) {
                        const cardElWrapper = createCardElement('X', 'X', false, true); 
                        cardElWrapper.classList.add('player-area-mini-card');
                        cardElWrapper.style.position = 'absolute';
                        cardElWrapper.style.left = `calc(50% + ${baseLeftOffset + i * miniCardStep}px)`;
                        cardElWrapper.style.bottom = `${i * 1.5}px`; 
                        cardElWrapper.style.transform = 'translateX(-50%)'; 
                        cardElWrapper.style.zIndex = i;
                        cardVisualsContainer.appendChild(cardElWrapper);
                    }
                }
                pa.appendChild(cardVisualsContainer);

                const revolverVisualsContainer = document.createElement('div');
                revolverVisualsContainer.className = 'player-revolver-visuals has-tooltip';
                const chambersLeft = opponent.revolverChambersLeft !== undefined ? opponent.revolverChambersLeft : REVOLVER_CHAMBERS;
                revolverVisualsContainer.dataset.tooltip = `Revolver Rounds: ${chambersLeft}/${REVOLVER_CHAMBERS}`;
                
                for (let i = 0; i < REVOLVER_CHAMBERS; i++) {
                    const chamberEl = document.createElement('span');
                    chamberEl.className = 'revolver-chamber';
                    if (i < chambersLeft) { 
                        chamberEl.classList.add('available');
                    } else { 
                        chamberEl.classList.add('fired');
                    }
                    revolverVisualsContainer.appendChild(chamberEl);
                }
                pa.appendChild(revolverVisualsContainer);
                
                playerAreasContainer.appendChild(pa);
            });

            if (gameState.currentPlayerId === localPlayer.id && !localPlayer.eliminated) {
                playerHandArea.classList.add('current-player-hand');
            } else {
                playerHandArea.classList.remove('current-player-hand');
            }
        }

        function renderLocalPlayerStats() {
            if (!localPlayerStatsArea || !localRevolverVisuals) return;
            const showStats = (gameState.gamePhase === 'playing' || 
                               gameState.gamePhase === 'challenge_reveal' || 
                               gameState.gamePhase === 'roulette' || 
                               gameState.gamePhase === 'roulette_resolved') && 
                              !localPlayer.eliminated;
            
            localPlayerStatsArea.style.display = showStats ? 'flex' : 'none';
            if (!showStats) return;

            localRevolverVisuals.innerHTML = '';
            const chambersLeft = localPlayer.revolverChambersLeft !== undefined ? localPlayer.revolverChambersLeft : REVOLVER_CHAMBERS;
            localRevolverVisuals.dataset.tooltip = `Revolver Rounds: ${chambersLeft}/${REVOLVER_CHAMBERS}`;

            for (let i = 0; i < REVOLVER_CHAMBERS; i++) {
                const chamberEl = document.createElement('span');
                chamberEl.className = 'revolver-chamber';
                if (i < chambersLeft) {
                    chamberEl.classList.add('available');
                } else {
                    chamberEl.classList.add('fired');
                }
                localRevolverVisuals.appendChild(chamberEl);
            }
        }


        function updateTableDisplay() { if (gameState.currentTableSuit) { tableTypeCardDiv.innerHTML = SUIT_SYMBOLS[gameState.currentTableSuit] || gameState.currentTableSuit; tableTypeCardDiv.style.color = SUIT_COLORS[gameState.currentTableSuit] || 'var(--primary-text)'; } else { tableTypeCardDiv.innerHTML = 'ðŸŽ²'; tableTypeCardDiv.style.color = 'var(--secondary-text)'; } if (gameState.lastPlayedTurn) { const count = gameState.lastPlayedTurn.cardsPlayedCount !== undefined ? gameState.lastPlayedTurn.cardsPlayedCount : 0; playedCardsPileInfo.textContent = `Last play: ${count} card(s) as ${SUIT_SYMBOLS[gameState.lastPlayedTurn.declaredSuit] || gameState.lastPlayedTurn.declaredSuit}.`;} else if (gameState.gamePhase === 'playing') { playedCardsPileInfo.textContent = "Awaiting first play..."; } else { playedCardsPileInfo.textContent = "---"; } updateCenterPileVisual(); }
        
        function updateCenterPileVisual() {
            if (!centerPileVisualStack) return;
            centerPileVisualStack.innerHTML = '';
            const numCardsInPile = gameState.centerPileCardCount !== undefined ? gameState.centerPileCardCount : 0;
            const maxVisualCards = 7; 

            if (numCardsInPile > 0) {
                for (let i = 0; i < Math.min(numCardsInPile, maxVisualCards); i++) {
                    const cardBackElement = createCardElement('X', 'X', false, true); 
                    const cardSvg = cardBackElement.querySelector('svg');
                    if (cardSvg) {
                        cardSvg.classList.add('card-back-dummy'); 
                        cardSvg.style.position = 'absolute';
                        const offsetX = (Math.random() - 0.5) * 4 + (i * 0.8);
                        const offsetY = (Math.random() - 0.5) * 4 - (i * 0.8);
                        cardSvg.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${(Math.random() - 0.5) * 3}deg)`;
                        cardSvg.style.zIndex = i;
                        centerPileVisualStack.appendChild(cardSvg);
                    }
                }
            }
        }

        function animatePlayedCards(playerId, numCardsPlayed) {
            if (numCardsPlayed === 0 || !gameBoardDiv) return;

            const sourceElement = (playerId === localPlayer.id) ? playerHandArea : playerAreasContainer.querySelector(`.player-area[data-player-id="${playerId}"]`);
            const targetElement = centerPileVisualStack;

            if (!sourceElement || !targetElement) {
                logDebug(`Animation source/target not found for player ${playerId}`);
                return;
            }

            const gameBoardRect = gameBoardDiv.getBoundingClientRect(); 
            const cardToAnimateContainer = createCardElement('A', 'S', false, true); 
            const cardToAnimate = cardToAnimateContainer.querySelector('svg');
            if (!cardToAnimate) return;

            const cardWidth = parseFloat(cardToAnimate.getAttribute('width'));
            const cardHeight = parseFloat(cardToAnimate.getAttribute('height'));

            cardToAnimate.style.position = 'absolute';
            cardToAnimate.style.zIndex = '100'; 
            
            const sourceRect = sourceElement.getBoundingClientRect();
            const initialX = (sourceRect.left + sourceRect.width / 2) - gameBoardRect.left - (cardWidth / 2);
            const initialY = (sourceRect.top + sourceRect.height / 2) - gameBoardRect.top - (cardHeight / 2);
            
            cardToAnimate.style.left = `${initialX}px`;
            cardToAnimate.style.top = `${initialY}px`;
            cardToAnimate.style.transform = 'scale(1.1) rotate(0deg)'; 
            cardToAnimate.style.opacity = '1';

            gameBoardDiv.appendChild(cardToAnimate);

            const targetRect = targetElement.getBoundingClientRect();
            const finalX = (targetRect.left + targetRect.width / 2) - gameBoardRect.left - (cardWidth / 2) + (Math.random() - 0.5) * 5;
            const finalY = (targetRect.top + targetRect.height / 2) - gameBoardRect.top - (cardHeight / 2) + (Math.random() - 0.5) * 5;
            const finalRotation = (Math.random() - 0.5) * 15; 

            requestAnimationFrame(() => {
                cardToAnimate.style.transition = 'left 0.6s cubic-bezier(0.3, 0, 0.4, 1), top 0.6s cubic-bezier(0.3, 0, 0.4, 1), transform 0.6s cubic-bezier(0.3, 0, 0.4, 1), opacity 0.5s ease-in 0.25s';
                requestAnimationFrame(() => {
                    cardToAnimate.style.left = `${finalX}px`;
                    cardToAnimate.style.top = `${finalY}px`;
                    cardToAnimate.style.transform = `scale(0.8) rotate(${finalRotation}deg)`; 
                    cardToAnimate.style.opacity = '0';
                });
            });

            cardToAnimate.addEventListener('transitionend', () => {
                if (cardToAnimate.parentElement) {
                    cardToAnimate.remove();
                }
            }, { once: true });
        }

        function updateActionButtons() { const amICurrentPlayer = gameState.currentPlayerId === localPlayer.id; const localPlayerData = gameState.players.find(p => p.id === localPlayer.id); const amEliminated = localPlayerData ? localPlayerData.eliminated : true; playCardsBtn.disabled = !amICurrentPlayer || amEliminated || gameState.gamePhase !== 'playing' || playConfirmArea.style.display === 'block'; callLiarBtn.disabled = !amICurrentPlayer || amEliminated || gameState.gamePhase !== 'playing' || !gameState.lastPlayedTurn || playConfirmArea.style.display === 'block'; if (amICurrentPlayer && !amEliminated) { playerHandArea.classList.add('current-player-hand'); } else { playerHandArea.classList.remove('current-player-hand');}}
        class LiarsDeckGameManager { static shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; }} static createLiarsDeck() { const d = []; SUITS.forEach(s => { RANKS.forEach(r => { d.push({ rank:r, suit:s, id: `${r}${s}` }); }); }); this.shuffleArray(d); return d;} static createTableDeck() { const sS=[...SUITS]; this.shuffleArray(sS); return sS;} static createRevolverDeck(){const d=[];for(let i=0;i<REVOLVER_CHAMBERS-REVOLVER_BULLETS;i++)d.push('blank');for(let i=0;i<REVOLVER_BULLETS;i++)d.push('lethal');this.shuffleArray(d);return d;} static dealCardsFromLiarsDeck(pl,dk,hs){pl.forEach(p=>{if(!p.eliminated){p.hand=[];for(let i=0;i<hs;i++)if(dk.length>0)p.hand.push(dk.pop());}else p.hand=[];p.cardCount=p.hand.length;});} static checkPlayedCardsTruth(pc,ts){if(!pc||pc.length===0)return true;for(const c of pc)if(c.suit!==ts)return false;return true;}}
        
        function sendMessage(type, payload, targetClientId = null) { 
            const msgObject = { type, payload, senderId: localPlayer.id }; // Send object directly
            if (localPlayer.isHost) { 
                if (targetClientId) { 
                    if (hostConnections[targetClientId]?.open) hostConnections[targetClientId].send(msgObject); 
                    else logDebug(`Host: Connection to ${targetClientId} not open or found.`); 
                } else {
                    Object.values(hostConnections).forEach(conn => { if (conn?.open) conn.send(msgObject); }); 
                }
            } else if (clientConnectionToHost?.open) {
                clientConnectionToHost.send(msgObject); 
            } else {
                logDebug("Client: Connection to host not open."); 
            }
        }
        
        function getConnectedAndActivePlayerIds() {
            let connectedIds = [];
            if (localPlayer.isHost) {
                connectedIds = [localPlayer.id, ...Object.keys(hostConnections).filter(id => hostConnections[id]?.open)];
            } else { 
                connectedIds = clientConnectionToHost?.open ? [localPlayer.id, clientConnectionToHost.peer] : [localPlayer.id];
            }
            return connectedIds.filter(id => gameState.players.some(p => p.id === id));
        }

        function handleIncomingMessage(data) { // data is now the actual object from PeerJS
            const msg = data; 
            logDebug(`Received: ${msg.type} from ${msg.senderId === localPlayer.id ? 'Self' : (gameState.players.find(p=>p.id === msg.senderId)?.name || msg.senderId )}`);
            const oldGameStateForLog = localPlayer.isHost ? null : JSON.parse(JSON.stringify(lastLoggedGameStateForClient)); 

            if (localPlayer.isHost) {
                switch (msg.type) {
                    case 'PLAYER_ACTION_PLAY_CARDS': handleHostPlayerPlayCards(msg.senderId, msg.payload.cards); break;
                    case 'PLAYER_ACTION_CALL_LIAR': handleHostPlayerCallLiar(msg.senderId); break;
                    case 'PLAYER_TOGGLE_REMATCH_READY':
                        if (gameState.gamePhase === 'game_over') {
                            const clientId = msg.senderId;
                            const clientPlayer = gameState.players.find(p => p.id === clientId);
                            const clientName = clientPlayer ? clientPlayer.name : clientId;

                            const eligiblePlayers = getConnectedAndActivePlayerIds();
                            if (!eligiblePlayers.includes(clientId)) {
                                logDebug(`Host: Received rematch ready from ${clientName} but they are no longer eligible. Ignoring.`);
                                if (gameState.rematchReadyStatus.hasOwnProperty(clientId)) {
                                    delete gameState.rematchReadyStatus[clientId];
                                    broadcastGameState(); 
                                }
                                return;
                            }

                            gameState.rematchReadyStatus[clientId] = msg.payload.isReady;
                            logDebug(`Host: Player ${clientName} readiness: ${msg.payload.isReady}`);
                            updateRematchStatusDisplay(); 

                            const allActuallyReady = eligiblePlayers.length > 0 &&
                                                     eligiblePlayers.every(id => gameState.rematchReadyStatus[id] === true);

                            if (eligiblePlayers.length >= MIN_PLAYERS && allActuallyReady) {
                                addLogMessage("All players ready! Starting rematch...", "success");
                                initializeNewGame(); 
                            } else {
                                broadcastGameState(); 
                            }
                        }
                        break;
                    case 'CLIENT_NAME_UPDATE': 
                        const pToUpdate = gameState.players.find(p => p.id === msg.senderId); 
                        if (pToUpdate) { 
                            pToUpdate.name = msg.payload.name; 
                            logDebug(`Host: Player ${msg.senderId} updated name to ${msg.payload.name}.`); 
                            updateConnectedPlayersDisplay(); 
                            broadcastGameState(); 
                        } else {
                            logDebug(`Host: Received CLIENT_NAME_UPDATE for unknown peerId ${msg.senderId}`);
                        }
                        break;
                }
            } else { // Client-side
                switch (msg.type) {
                    case 'GAME_STATE_UPDATE':
                        const oldPhase = lastLoggedGameStateForClient?.gamePhase; 
                        const wasGameOver = oldPhase === 'game_over';

                        Object.assign(gameState, msg.payload.gameState);
                        localPlayer.hand = msg.payload.yourHand !== undefined ? msg.payload.yourHand : localPlayer.hand;
                        const myPlayerDataFromState = gameState.players.find(p => p.id === localPlayer.id);
                        if (myPlayerDataFromState) { Object.assign(localPlayer, myPlayerDataFromState); }

                        if (gameState.gamePhase === 'playing' && oldGameStateForLog && Object.keys(oldGameStateForLog).length > 0) {
                            if (gameState.currentTableSuit !== oldGameStateForLog.currentTableSuit && gameState.currentTableSuit) {
                                addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system");
                            }
                            if (gameState.lastPlayedTurn && JSON.stringify(gameState.lastPlayedTurn) !== JSON.stringify(oldGameStateForLog.lastPlayedTurn)) { 
                                addLogMessage(`${gameState.lastPlayedTurn.playerName} plays ${gameState.lastPlayedTurn.cardsPlayedCount} as ${SUIT_SYMBOLS[gameState.lastPlayedTurn.declaredSuit]}.`, "system");
                                animatePlayedCards(gameState.lastPlayedTurn.playerId, gameState.lastPlayedTurn.cardsPlayedCount);
                            }
                             if (gameState.currentPlayerId !== oldGameStateForLog.currentPlayerId && gameState.currentPlayerId) {
                                const currPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                                if(currPlayer) addLogMessage(`${currPlayer.name}'s turn.`, "system");
                            }
                        } else if (gameState.gamePhase === 'playing' && gameState.currentTableSuit && (!oldGameStateForLog || Object.keys(oldGameStateForLog).length === 0 || !oldGameStateForLog.currentTableSuit)){
                            addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system");
                            const currPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                            if(currPlayer) addLogMessage(`${currPlayer.name}'s turn.`, "system");
                        }

                        if (gameState.gamePhase === 'playing' && wasGameOver) { 
                            logDebug("Client: Rematch started! Transitioning UI.");
                            if (gameOverOverlay.classList.contains('visible')) {
                                toggleModal(gameOverOverlay, false); 
                            }
                            showGameBoard(); 
                        } else if ((gameState.gamePhase !== 'lobby') && connectionSetupDiv.style.display !== 'none') {
                            showGameBoard();
                        } else if (gameState.gamePhase === 'lobby' && gameBoardDiv.style.display !== 'none') {
                            showConnectionSetup();
                        }
                        
                        if (gameState.gamePhase !== 'lobby' && !(gameState.gamePhase === 'playing' && wasGameOver)) {
                            updateFullUI();
                        }

                        if (gameState.gamePhase === 'game_over') {
                            if (JSON.stringify(gameState.rematchReadyStatus) !== JSON.stringify(oldGameStateForLog?.rematchReadyStatus)) {
                                updateRematchStatusDisplay(); 
                                localPlayer.readyForRematch = gameState.rematchReadyStatus[localPlayer.id] === true;
                                playAgainBtn.textContent = localPlayer.readyForRematch ? "Waiting for Others..." : "Ready for Rematch";
                                playAgainBtn.style.backgroundColor = localPlayer.readyForRematch ? 'var(--accent-green)' : 'var(--accent-gold)';
                            }
                        }
                        lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState));
                        break;
                    case 'CHALLENGE_ROULETTE_RESULTS': 
                        handleClientChallengeRouletteResults(msg.payload); 
                        lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState)); 
                        break;
                    case 'GAME_OVER': handleClientGameOver(msg.payload); lastLoggedGameStateForClient = {}; break;
                    case 'PLAYER_JOINED_ACK': 
                        clientStatusP.textContent = `Joined room hosted by ${msg.payload.hostName}! Waiting for game...`;
                        clientStatusP.style.color = "var(--accent-green)";
                        // localPlayer.id is already set from client's peer.on('open')
                        gameState.players = msg.payload.players; 
                        // Ensure localPlayer object is updated based on the authoritative list from host
                        const myInitialData = gameState.players.find(p => p.id === localPlayer.id);
                        if (myInitialData) Object.assign(localPlayer, myInitialData);
                        updatePlayerNameDisplay(); 
                        lastLoggedGameStateForClient = JSON.parse(JSON.stringify(gameState)); 
                        break;
                    case 'HOST_DISCONNECTED': 
                        alert("Host disconnected. Returning to setup."); 
                        showConnectionSetup(); 
                        lastLoggedGameStateForClient = {}; 
                        break;
                }
            }
        }
        
        function initializeNewGame() {
            if (!localPlayer.isHost) return;
            logDebug("Host: Initializing new game (standard deck).");

            const playerIdsFromPreviousGame = gameState.players.map(p => p.id);
            const connectedAndEligibleIds = getConnectedAndActivePlayerIds() 
                                              .filter(id => playerIdsFromPreviousGame.includes(id)); 

            let newGamePlayersList = [];
            gameState.players.forEach(oldPlayer => { 
                if (connectedAndEligibleIds.includes(oldPlayer.id)) {
                    newGamePlayersList.push({
                        id: oldPlayer.id, 
                        name: oldPlayer.name,
                        isHost: oldPlayer.isHost,
                        eliminated: false, 
                        hand: [], 
                        revolverDeck: LiarsDeckGameManager.createRevolverDeck(),
                        revolverChambersLeft: REVOLVER_CHAMBERS,
                        cardCount: 0
                    });
                }
            });
            
            if (!newGamePlayersList.some(p => p.id === localPlayer.id)) {
                newGamePlayersList.unshift({ 
                    id: localPlayer.id, name: localPlayer.name, isHost: true,
                    eliminated: false, hand: [], revolverDeck: LiarsDeckGameManager.createRevolverDeck(),
                    revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0
                });
                newGamePlayersList = [...new Map(newGamePlayersList.map(item => [item.id, item])).values()];
            }

            newGamePlayersList.sort((a, b) => { if (a.isHost) return -1; if (b.isHost) return 1; return 0; }); 
            gameState.players = newGamePlayersList; 

            gameState.rematchReadyStatus = {}; 
            gameState.liarsDeck = LiarsDeckGameManager.createLiarsDeck();
            gameState.tableDeck = LiarsDeckGameManager.createTableDeck();
            gameState.centerPile = [];
            gameState.centerPileCardCount = 0;
            gameState.lastPlayedTurn = null;
            gameState.currentPlayerId = null; 

            if (gameOverOverlay.classList.contains('visible')) {
                 toggleModal(gameOverOverlay, false);
            }
            
            startNewRound();
        }

        function startNewRound() { if (!localPlayer.isHost) return; logDebug("Host: Starting new round (suit based)."); if (gameState.tableDeck.length === 0) gameState.tableDeck = LiarsDeckGameManager.createTableDeck(); gameState.currentTableSuit = gameState.tableDeck.pop(); addLogMessage(`New Round! Table Suit is: ${SUIT_SYMBOLS[gameState.currentTableSuit]} (${gameState.currentTableSuit})`, "system"); const activePlayers = gameState.players.filter(p => !p.eliminated); if (gameState.liarsDeck.length < activePlayers.length * HAND_SIZE) { gameState.liarsDeck = LiarsDeckGameManager.createLiarsDeck(); addLogMessage("Liar's Deck (standard) reshuffled.", "system"); } LiarsDeckGameManager.dealCardsFromLiarsDeck(gameState.players, gameState.liarsDeck, HAND_SIZE); gameState.centerPile = []; gameState.centerPileCardCount = 0; gameState.lastPlayedTurn = null; const uneliminatedPlayers = gameState.players.filter(p => !p.eliminated); if (uneliminatedPlayers.length === 0) { logDebug("Error: No uneliminated players."); return; } let currentPlayerIndex = 0; if (gameState.currentPlayerId) { const lastPlayerOrderIndex = gameState.players.findIndex(p => p.id === gameState.currentPlayerId); if (lastPlayerOrderIndex !== -1) { currentPlayerIndex = (lastPlayerOrderIndex + 1) % gameState.players.length; }} let attempts = 0; while (attempts < gameState.players.length && gameState.players[currentPlayerIndex].eliminated) { currentPlayerIndex = (currentPlayerIndex + 1) % gameState.players.length; attempts++; } if (gameState.players[currentPlayerIndex].eliminated) { logDebug("Error: Could not find uneliminated starting player."); const firstActiveFallback = gameState.players.findIndex(p => !p.eliminated); if (firstActiveFallback !== -1) currentPlayerIndex = firstActiveFallback; else { logDebug("CRITICAL Error: No uneliminated players."); return; }} gameState.currentPlayerId = gameState.players[currentPlayerIndex].id; gameState.gamePhase = 'playing'; const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name || "Unknown"; addLogMessage(`${currentPlayerName}'s turn.`, "system"); broadcastGameState(); }
        
        function handleHostPlayerPlayCards(playerId, playedCardIds) { 
            if (!localPlayer.isHost || playerId !== gameState.currentPlayerId || gameState.gamePhase !== 'playing') return; 
            const player = gameState.players.find(p => p.id === playerId); 
            if (!player || player.eliminated) return; 
            if (!playedCardIds || playedCardIds.length === 0 || playedCardIds.length > 3) { logDebug(`Invalid play count for ${playerId}.`); return; } 
            const actualPlayedCards = []; const remainingHand = []; 
            player.hand.forEach(card => { (playedCardIds.includes(card.id)) ? actualPlayedCards.push(card) : remainingHand.push(card); }); 
            if (actualPlayedCards.length !== playedCardIds.length) { logDebug(`Card mismatch for ${playerId}.`); return; } 
            player.hand = remainingHand; player.cardCount = player.hand.length; 
            gameState.lastPlayedTurn = { playerId, playerName: player.name, cardsPlayed: actualPlayedCards, cardsPlayedCount: actualPlayedCards.length, declaredSuit: gameState.currentTableSuit }; 
            gameState.centerPile.push(...actualPlayedCards); gameState.centerPileCardCount = gameState.centerPile.length; 
            addLogMessage(`${player.name} plays ${actualPlayedCards.length} as ${SUIT_SYMBOLS[gameState.currentTableSuit]}.`, "system"); 
            
            if (gameBoardDiv.style.display === 'block') {
                animatePlayedCards(playerId, actualPlayedCards.length);
            }

            let currentIdx = gameState.players.findIndex(p => p.id === playerId); 
            let attempts = 0; let nextFound = false; 
            if (gameState.players.length > 0) { 
                do { currentIdx = (currentIdx + 1) % gameState.players.length; attempts++; if (!gameState.players[currentIdx].eliminated) { nextFound = true; break; } } while (attempts < gameState.players.length * 2); 
            } 
            if (nextFound) gameState.currentPlayerId = gameState.players[currentIdx].id; 
            else logDebug("No next player found after play."); 
            const totalCardsInHands = gameState.players.reduce((sum, p) => sum + (p.eliminated ? 0 : p.hand.length), 0); 
            if (totalCardsInHands === 0 && gameState.liarsDeck.length === 0) { 
                addLogMessage("All cards played! Auto-challenge.", "system"); 
                if (nextFound) handleHostPlayerCallLiar(gameState.players[currentIdx].id); 
                else logDebug("All cards played, no challenger."); 
                return; 
            } 
            broadcastGameState(); 
        }

        function handleHostPlayerCallLiar(challengerId) { if (!localPlayer.isHost || challengerId !== gameState.currentPlayerId || !gameState.lastPlayedTurn || gameState.gamePhase !== 'playing') return; const challenger = gameState.players.find(p => p.id === challengerId); const accusedId = gameState.lastPlayedTurn.playerId; const accused = gameState.players.find(p => p.id === accusedId); if (!challenger || challenger.eliminated || !accused) { logDebug("Challenge error: invalid players."); return; } addLogMessage(`${challenger.name} calls LIAR! on ${accused.name}.`, "system"); gameState.gamePhase = 'challenge_reveal'; const played = gameState.lastPlayedTurn.cardsPlayed; const tableSuit = gameState.currentTableSuit; const wasLie = !LiarsDeckGameManager.checkPlayedCardsTruth(played, tableSuit); let rouletteTargetId; if (wasLie) { addLogMessage(`${accused.name} was LYING! (Not all ${SUIT_SYMBOLS[tableSuit]})`, "error"); rouletteTargetId = accusedId; } else { addLogMessage(`${accused.name} was TRUTHFUL! (All ${SUIT_SYMBOLS[tableSuit]})`, "success"); rouletteTargetId = challengerId; } const target = gameState.players.find(p => p.id === rouletteTargetId); if (!target || target.eliminated) { logDebug(`Roulette target ${target?.name || rouletteTargetId} gone.`); startNewRound(); return; } if (!target.revolverDeck || target.revolverDeck.length === 0) { target.revolverDeck = LiarsDeckGameManager.createRevolverDeck(); target.revolverChambersLeft = REVOLVER_CHAMBERS; addLogMessage(`${target.name}'s revolver reloaded.`, "system"); } const fired = target.revolverDeck.pop(); target.revolverChambersLeft = target.revolverDeck.length; let outcomeText; if (fired === 'lethal') { target.eliminated = true; target.cardCount = 0; outcomeText = `BANG! ${target.name} ELIMINATED!`; addLogMessage(outcomeText, "error"); } else { outcomeText = `CLICK! ${target.name} survives.`; addLogMessage(outcomeText, "system"); if (target.revolverDeck.length === 0) { addLogMessage(`${target.name}'s revolver empty, reloaded.`, "system"); target.revolverDeck = LiarsDeckGameManager.createRevolverDeck(); target.revolverChambersLeft = REVOLVER_CHAMBERS;}} gameState.players.forEach(p => p.cardCount = p.eliminated ? 0 : p.hand.length); const results = { challenger:{id:challenger.id,name:challenger.name}, accused:{id:accused.id,name:accused.name}, playedCards:played, tableSuit:tableSuit, claimWasLie:wasLie, rouletteTarget:{id:target.id,name:target.name}, rouletteOutcome:fired, rouletteOutcomeText:outcomeText, updatedPlayersData: gameState.players.map(p=>({id:p.id,name:p.name,eliminated:p.eliminated,revolverChambersLeft:p.revolverChambersLeft,cardCount:p.cardCount}))}; sendMessage('CHALLENGE_ROULETTE_RESULTS',results); handleClientChallengeRouletteResults(results); const uneliminated = gameState.players.filter(p=>!p.eliminated); if(uneliminated.length<=1){gameState.gamePhase='game_over';const winner=uneliminated.length===1?uneliminated[0]:null;const goData={winner:winner?{id:winner.id,name:winner.name}:null,reason:winner?`${winner.name} is the last one standing!`:"It's a draw... or mutual destruction!"};sendMessage('GAME_OVER',goData);handleClientGameOver(goData);}else{gameState.gamePhase='roulette_resolved';broadcastGameState();setTimeout(()=>{if(gameState.gamePhase==='roulette_resolved')startNewRound();},3500);}}
        
        function handleClientChallengeRouletteResults(data) { 
            rouletteResultTextP.textContent = ''; 
            if (localPlayer.id !== data.challenger.id && localPlayer.id !== data.accused.id) { 
                addLogMessage(`${data.challenger.name} calls LIAR! on ${data.accused.name}.`, "system");
            }
            if (data.claimWasLie) { addLogMessage(`${data.accused.name} was LYING! (Not all ${SUIT_SYMBOLS[data.tableSuit]})`, "error");} 
            else { addLogMessage(`${data.accused.name} was TRUTHFUL! (All ${SUIT_SYMBOLS[data.tableSuit]})`, "success");}

            gameState.gamePhase = 'roulette'; 
            data.updatedPlayersData.forEach(updP => { const pLocal = gameState.players.find(p => p.id === updP.id); if (pLocal) Object.assign(pLocal, updP); if (localPlayer.id === updP.id) Object.assign(localPlayer, updP); }); 
            challengeRouletteTitle.textContent = data.claimWasLie ? `${data.accused.name} CAUGHT LYING!` : `CHALLENGE FAILED!`; 
            challengeRouletteDetailsP.textContent = `${data.challenger.name} challenged ${data.accused.name}. Claimed Suit: ${SUIT_SYMBOLS[data.tableSuit]}.`; 
            revealedCardsDisplay.innerHTML = ''; data.playedCards.forEach(c => revealedCardsDisplay.appendChild(createCardElement(c.rank, c.suit, true, true))); 
            challengeRouletteConsequenceP.textContent = `${data.rouletteTarget.name} faces the Roulette!`; 
            
            if (rouletteSymbolInterval) clearInterval(rouletteSymbolInterval);
            const rouletteSymbols = ['<span style="font-size:2em; padding: 0 5px;">ðŸƒ</span>', '<span style="font-size:2em; padding: 0 5px;">ðŸŽ²</span>', '<span style="font-size:2em; padding: 0 5px;">â”</span>', '<span style="font-size:2em; padding: 0 5px;">ðŸ’€</span>', '<span style="font-size:2em; padding: 0 5px;">ðŸ¤ž</span>'];
            let symbolIndex = 0;
            rouletteAnimationDiv.innerHTML = rouletteSymbols[0];
            rouletteAnimationDiv.classList.add('spinning');
            
            rouletteSymbolInterval = setInterval(() => {
                symbolIndex = (symbolIndex + 1) % rouletteSymbols.length;
                rouletteAnimationDiv.innerHTML = rouletteSymbols[symbolIndex];
            }, 150);

            setTimeout(() => {
                if (rouletteSymbolInterval) clearInterval(rouletteSymbolInterval);
                rouletteAnimationDiv.classList.remove('spinning'); 
                rouletteAnimationDiv.innerHTML = data.rouletteOutcome === 'lethal' ? `<span style="font-size:2.2em; color: var(--accent-red-darker); font-weight:bold;">ðŸ’¥ BANG! ðŸ’¥</span>` : `<span style="font-size:2.2em; color: var(--accent-green-darker); font-weight:bold;">ðŸ’¨ Click! ðŸ’¨</span>`;
                rouletteResultTextP.textContent = data.rouletteOutcomeText; 
                rouletteResultTextP.style.color = data.rouletteOutcome === 'lethal' ? 'var(--accent-red)' : 'var(--accent-green)';
                addLogMessage(data.rouletteOutcomeText, data.rouletteOutcome === 'lethal' ? "error" : "system"); 
            }, 2000); 
            
            toggleModal(challengeRouletteOverlay, true); updateFullUI(); 
        }

        function updateRematchStatusDisplay() {
            if (gameState.gamePhase !== 'game_over' || !rematchStatusContainer) {
                if(rematchStatusContainer) rematchStatusContainer.style.display = 'none';
                return;
            }
            rematchStatusContainer.style.display = 'block';
            rematchStatusListDiv.innerHTML = '';

            const eligibleForRematchDisplay = getConnectedAndActivePlayerIds();
            
            eligibleForRematchDisplay.forEach(playerId => {
                const player = gameState.players.find(p => p.id === playerId);
                if (player) { 
                    const statusSpan = document.createElement('span');
                    const isReady = gameState.rematchReadyStatus[playerId] === true; 
                    statusSpan.textContent = `${player.name}: ${isReady ? 'Ready ðŸ‘' : 'Not Ready...'}`;
                    statusSpan.className = isReady ? 'ready' : 'not-ready';
                    rematchStatusListDiv.appendChild(statusSpan);
                }
            });
        }

        function handleClientGameOver(data) {
            gameState.gamePhase = 'game_over';
            gameState.rematchReadyStatus = {}; 
            
            const eligibleForRematchInit = getConnectedAndActivePlayerIds();
            eligibleForRematchInit.forEach(id => {
                gameState.rematchReadyStatus[id] = false;
            });

            localPlayer.readyForRematch = false; 

            gameOverTitle.textContent = data.winner ? `ðŸ‘‘ ${data.winner.name} Wins! ðŸ‘‘` : "Game Over!";
            gameOverMessageP.textContent = data.reason;
            addLogMessage(data.reason, "system");

            playAgainBtn.textContent = "Ready for Rematch";
            playAgainBtn.style.backgroundColor = 'var(--accent-gold)';
            playAgainBtn.disabled = false;

            updateRematchStatusDisplay();
            toggleModal(gameOverOverlay, true);
            toggleModal(challengeRouletteOverlay, false);
            updateActionButtons(); 
            updateFullUI(); 
        }

        function broadcastGameState() { 
            if (!localPlayer.isHost) return; 
            const common = { 
                players: gameState.players.map(p => ({ id: p.id, name: p.name, isHost: p.isHost, eliminated: p.eliminated, revolverChambersLeft: p.revolverChambersLeft, cardCount: p.cardCount })), 
                currentPlayerId: gameState.currentPlayerId, 
                currentTableSuit: gameState.currentTableSuit, 
                lastPlayedTurn: gameState.lastPlayedTurn ? { playerId:gameState.lastPlayedTurn.playerId,playerName:gameState.lastPlayedTurn.playerName,cardsPlayedCount:gameState.lastPlayedTurn.cardsPlayedCount,declaredSuit:gameState.lastPlayedTurn.declaredSuit}:null, 
                gamePhase: gameState.gamePhase, 
                centerPileCardCount: gameState.centerPile.length,
                rematchReadyStatus: gameState.rematchReadyStatus 
            }; 
            gameState.players.forEach(p => { 
                if (p.id !== localPlayer.id && hostConnections[p.id]?.open) { 
                    sendMessage('GAME_STATE_UPDATE', { gameState: { ...common }, yourHand: p.hand }, p.id); 
                } 
            }); 
            const myPData = gameState.players.find(p => p.id === localPlayer.id); 
            if (myPData) Object.assign(localPlayer, myPData); 
            updateFullUI(); 
        }
        function showConnectionSetup() { 
            connectionSetupDiv.style.display = 'flex'; 
            gameBoardDiv.style.display = 'none'; 
            toggleModal(gameOverOverlay, false); 
            toggleModal(challengeRouletteOverlay, false); 
            hostControlsDiv.style.display = 'none'; 
            clientControlsDiv.style.display = 'none'; 
            roomCodeDisplay.textContent = 'Waiting for Room Code...';
            roomCodeInput.value = '';
            connectedPlayersCountSpan.textContent = `0 / ${MAX_PLAYERS - 1}`; 
            connectedPlayersListDiv.innerHTML = ''; 
            startGameBtn.disabled = true; 
            clientStatusP.textContent = 'Enter your name above, then the Room Code from the host and click "Connect to Host".';
            clientStatusP.style.color = 'var(--secondary-text)';
            
            if (localPlayer.peer) {
                localPlayer.peer.destroy(); 
                localPlayer.peer = null;
            }

            const currentName = playerNameInput.value || localPlayer.name; 
            localPlayer = { id: null, name: currentName, peer: null, isHost: false, hand: [], eliminated: false, revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount:0, readyForRematch: false }; 
            if(currentName) playerNameInput.value = currentName; 
            
            gameState = { players: [], liarsDeck: [], tableDeck: [], centerPile: [], currentPlayerId: null, currentTableSuit: null, lastPlayedTurn: null, gamePhase: 'lobby', config: { handSize: HAND_SIZE }, centerPileCardCount: 0, rematchReadyStatus: {} }; 
            
            hostConnections = {}; 
            clientConnectionToHost = null; 
            
            logDebug("UI reset to connection setup."); 
            lastLoggedGameStateForClient = {}; 
            logMessagesDiv.innerHTML = ''; 
            localPlayerStatsArea.style.display = 'none';
        }
        
        function showGameBoard() {
            connectionSetupDiv.style.display = 'none';
            gameBoardDiv.style.display = 'block';
            if (gameOverOverlay.classList.contains('visible')) { 
                toggleModal(gameOverOverlay, false);
            }
            if (challengeRouletteOverlay.classList.contains('visible')) { 
                toggleModal(challengeRouletteOverlay, false);
            }
            updateFullUI();
        }
        
        function updateFullUI() { 
            if (gameState.gamePhase === 'lobby' && gameBoardDiv.style.display === 'none') return; 
            renderPlayerHand(); 
            renderPlayerAreas(); 
            renderLocalPlayerStats(); 
            updateTableDisplay(); 
            updateActionButtons(); 
            if (playConfirmArea.style.display === 'block') { 
                const amICurr = gameState.currentPlayerId === localPlayer.id; 
                if(!amICurr || gameState.gamePhase !== 'playing') { 
                    enableHandCardSelectionForPlay(false); 
                }
            }
            if (gameState.gamePhase === 'game_over') { 
                updateRematchStatusDisplay();
            }
        }

        function updatePlayerNameDisplay() { playerNameInput.value = localPlayer.name; }
        
        function initializePeerJSHost() {
            if (localPlayer.peer) localPlayer.peer.destroy();
            localPlayer.peer = new Peer();

            localPlayer.peer.on('open', (id) => {
                localPlayer.id = id; 
                roomCodeDisplay.textContent = id;
                logDebug(`Host PeerJS ID (Room Code): ${id}`);
                addLogMessage(`Room created! Share Code: ${id}`, "success");
                clientStatusP.textContent = ""; 

                gameState.players = [{
                    id: localPlayer.id, name: localPlayer.name, isHost: true, eliminated: false, 
                    hand: [], revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0
                }];
                updateConnectedPlayersDisplay();
            });

            localPlayer.peer.on('connection', (conn) => {
                logDebug(`Host: Incoming connection from ${conn.peer}`);
                if (Object.keys(hostConnections).length >= MAX_PLAYERS -1) {
                    logDebug(`Host: Room full. Rejecting connection from ${conn.peer}`);
                    conn.on('open', () => conn.send({ type: 'ROOM_FULL_REJECT' }) ); 
                    setTimeout(() => conn.close(), 500); 
                    return;
                }

                hostConnections[conn.peer] = conn;

                conn.on('open', () => {
                    logDebug(`Host: DataConnection open with ${conn.peer}`);
                    const newPlayer = { 
                        id: conn.peer, 
                        name: `Player ${Object.keys(hostConnections).length + 1}`, 
                        isHost: false, eliminated: false, hand: [], 
                        revolverDeck: [], revolverChambersLeft: REVOLVER_CHAMBERS, cardCount: 0 
                    };
                    gameState.players.push(newPlayer);
                    updateConnectedPlayersDisplay();

                    sendMessage('PLAYER_JOINED_ACK', { 
                        yourId: conn.peer, 
                        hostName: localPlayer.name,
                        players: gameState.players.map(p => ({ id: p.id, name: p.name, isHost: p.isHost, cardCount: p.cardCount }))
                    }, conn.peer);
                });

                conn.on('data', (data) => {
                    handleIncomingMessage(data);
                });

                conn.on('close', () => {
                    logDebug(`Host: Connection with ${conn.peer} closed.`);
                    handleClientDisconnect(conn.peer);
                });
                conn.on('error', (err) => {
                    logDebug(`Host: Error with connection ${conn.peer}: ${err}`);
                    handleClientDisconnect(conn.peer); 
                });
            });

            localPlayer.peer.on('disconnected', () => {
                logDebug("Host: Disconnected from PeerJS server. Attempting to reconnect...");
                clientStatusP.textContent = "Lost connection to signaling server. Reconnecting...";
                clientStatusP.style.color = "var(--accent-red)";
                if (localPlayer.peer && !localPlayer.peer.destroyed) localPlayer.peer.reconnect();
            });
            localPlayer.peer.on('error', (err) => {
                logDebug(`Host: PeerJS error: ${err.type} - ${err}`);
                roomCodeDisplay.textContent = 'Error connecting to PeerServer';
                if (err.type === 'unavailable-id') {
                    alert("Error: The chosen Room ID is already in use. Please try creating the room again, a new ID will be generated.");
                    showConnectionSetup();
                } else if (err.type === 'network' || err.type === 'server-error' || err.type === 'socket-error' || err.type === 'socket-closed') {
                     clientStatusP.textContent = "Error connecting to PeerJS server. Check connection or try refreshing.";
                     clientStatusP.style.color = "var(--accent-red)";
                } else {
                    clientStatusP.textContent = `Connection error: ${err.type}. Try refreshing.`;
                    clientStatusP.style.color = "var(--accent-red)";
                }
            });
        }

        function connectToPeerJSClient(hostPeerId) {
            if (localPlayer.peer) localPlayer.peer.destroy();
            localPlayer.peer = new Peer();

            localPlayer.peer.on('open', (id) => {
                localPlayer.id = id; 
                logDebug(`Client PeerJS ID: ${id}. Attempting to connect to host: ${hostPeerId}`);
                
                const conn = localPlayer.peer.connect(hostPeerId, {reliable: true});
                clientConnectionToHost = conn;

                conn.on('open', () => {
                    logDebug(`Client: DataConnection open with host ${conn.peer}`);
                    clientStatusP.textContent = `Connected to host! Waiting for acknowledgement...`;
                    clientStatusP.style.color = "var(--accent-green)";
                    sendMessage('CLIENT_NAME_UPDATE', { name: localPlayer.name });
                });

                conn.on('data', (data) => {
                    if (data.type === 'ROOM_FULL_REJECT') {
                        alert("Host's room is full. Cannot join.");
                        showConnectionSetup();
                        return;
                    }
                    handleIncomingMessage(data);
                });

                conn.on('close', () => {
                    logDebug(`Client: Connection with host ${conn.peer} closed.`);
                    clientStatusP.textContent = "Disconnected from host.";
                    clientStatusP.style.color = "var(--accent-red)";
                    if (gameState.gamePhase !== 'game_over' && gameState.gamePhase !== 'lobby') {
                         alert("Lost connection to the host.");
                         showConnectionSetup();
                    }
                });
                conn.on('error', (err) => {
                    logDebug(`Client: Error with host connection ${conn.peer}: ${err}`);
                    clientStatusP.textContent = `Error connecting to host: ${err.type}.`;
                    clientStatusP.style.color = "var(--accent-red)";
                });
            });

            localPlayer.peer.on('disconnected', () => {
                logDebug("Client: Disconnected from PeerJS server. Attempting to reconnect...");
                 clientStatusP.textContent = "Lost connection to signaling server. Reconnecting...";
                 clientStatusP.style.color = "var(--accent-red)";
                if (localPlayer.peer && !localPlayer.peer.destroyed) localPlayer.peer.reconnect();
            });
            localPlayer.peer.on('error', (err) => {
                logDebug(`Client: PeerJS error: ${err.type} - ${err}`);
                 if (err.type === 'peer-unavailable') {
                    clientStatusP.textContent = `Host (${hostPeerId}) not found. Check Room Code and that host is active.`;
                    clientStatusP.style.color = "var(--accent-red)";
                } else if (err.type === 'network' || err.type === 'server-error' || err.type === 'socket-error' || err.type === 'socket-closed') {
                     clientStatusP.textContent = "Error connecting to PeerJS server. Check connection or try refreshing.";
                     clientStatusP.style.color = "var(--accent-red)";
                } else {
                    clientStatusP.textContent = `Connection error: ${err.type}. Try refreshing.`;
                    clientStatusP.style.color = "var(--accent-red)";
                }
            });
        }

        function handleClientDisconnect(clientId){ 
            logDebug(`Host: Client ${gameState.players.find(p=>p.id===clientId)?.name||clientId} disconnect processing.`);
            
            if(hostConnections[clientId]){
                if (hostConnections[clientId].close) hostConnections[clientId].close(); 
                delete hostConnections[clientId];
            }

            const dP = gameState.players.find(p=>p.id===clientId);
            let gameLogicChanged = false;

            if(dP){
                if (gameState.gamePhase === 'game_over') {
                    let statusActuallyChanged = false;
                    if (gameState.rematchReadyStatus.hasOwnProperty(clientId)) {
                        delete gameState.rematchReadyStatus[clientId];
                        statusActuallyChanged = true; 
                    }
                    addLogMessage(`${dP.name} disconnected. No longer part of rematch.`, "system");
                    statusActuallyChanged = true; 

                    const eligibleRematchPlayers = getConnectedAndActivePlayerIds(); 
                    const allActuallyReady = eligibleRematchPlayers.length > 0 &&
                                             eligibleRematchPlayers.every(id => gameState.rematchReadyStatus[id] === true);

                    if (eligibleRematchPlayers.length >= MIN_PLAYERS && allActuallyReady) {
                        addLogMessage("All remaining players ready! Starting rematch...", "success");
                        initializeNewGame(); 
                    } else if (statusActuallyChanged) { 
                         broadcastGameState(); 
                    }
                } else if (!dP.eliminated && ['playing','challenge_reveal','roulette','roulette_resolved'].includes(gameState.gamePhase)){
                    dP.eliminated=true; dP.cardCount=0; addLogMessage(`${dP.name} disconnected & was eliminated.`, "system"); gameLogicChanged=true;
                    const unelim=gameState.players.filter(p=>!p.eliminated);
                    if(unelim.length<=1 && gameState.gamePhase!=='game_over'){ 
                        gameState.gamePhase='game_over';
                        const winner=unelim.length===1?unelim[0]:null;
                        const goD={winner:winner?{id:winner.id,name:winner.name}:null,reason:winner?`${winner.name} wins by default (opponent disconnected)!`:"Game ended due to disconnections."};
                        sendMessage('GAME_OVER',goD);
                        handleClientGameOver(goD); 
                    } else if(gameState.gamePhase!=='game_over' && gameState.currentPlayerId===clientId){ 
                        let cpi=gameState.players.findIndex(p=>p.id===clientId);
                        let att=0;let nextF=false;
                        if(gameState.players.length>0){
                            do {cpi=(cpi+1)%gameState.players.length;att++;if(!gameState.players[cpi].eliminated){nextF=true;break;}}
                            while(att<gameState.players.length*2);
                        }
                        if(nextF){gameState.currentPlayerId=gameState.players[cpi].id;addLogMessage(`Turn passed to ${gameState.players.find(p=>p.id===gameState.currentPlayerId)?.name}.`,"system");}
                        else logDebug("Disconnect: No next player found.");
                    }
                } else if(gameState.gamePhase==='lobby'){
                    gameState.players=gameState.players.filter(p=>p.id!==clientId);
                    gameLogicChanged=true;
                }
            } 

            updateConnectedPlayersDisplay(); 

            if(gameLogicChanged && gameState.gamePhase !== 'game_over' && gameState.gamePhase !== 'playing_starting_new_round') { 
                if(!(gameState.gamePhase === 'game_over' && dP && (gameState.players.filter(p=>!p.eliminated).length <=1) )) { 
                     if (gameState.gamePhase !== 'lobby' || (gameState.gamePhase === 'lobby' && dP)) { 
                        broadcastGameState();
                     }
                }
            }
        }

        function updateConnectedPlayersDisplay(){
            const openConnectionsCount = Object.values(hostConnections).filter(conn => conn?.open).length;
            connectedPlayersCountSpan.textContent = `${openConnectionsCount} / ${MAX_PLAYERS - 1}`;
            
            connectedPlayersListDiv.innerHTML = '';
            if (localPlayer.isHost && gameState.players.find(p => p.id === localPlayer.id)) { 
                 const hostSpan = document.createElement('span'); 
                 hostSpan.textContent = `${localPlayer.name} (Host)`; 
                 hostSpan.style.fontWeight = 'bold'; 
                 connectedPlayersListDiv.appendChild(hostSpan); 
            }

            gameState.players.filter(p => !p.isHost && hostConnections[p.id]?.open).forEach(p=>{
                const s=document.createElement('span');
                s.textContent = p.name;
                connectedPlayersListDiv.appendChild(s);
            });
            
            const totalPlayersInGame = gameState.players.filter(p => p.isHost || hostConnections[p.id]?.open).length;
            startGameBtn.disabled = !(totalPlayersInGame >= MIN_PLAYERS && totalPlayersInGame <= MAX_PLAYERS);
        }
        
        function handleHandCardClickForPlay(event){const cE=event.currentTarget;const cId=cE.dataset.cardId;const idx=selectedCardsForPlayUI.findIndex(c=>c.id===cId);if(idx>-1){selectedCardsForPlayUI.splice(idx,1);cE.classList.remove('selected-for-play');}else{if(selectedCardsForPlayUI.length<3){const cardInH=localPlayer.hand.find(c=>c.id===cId);if(cardInH){selectedCardsForPlayUI.push(cardInH);cE.classList.add('selected-for-play');}}else addLogMessage("Max 3 cards can be selected.", "error");}updatePlayConfirmArea();}
        function updatePlayConfirmArea(){if(selectedCardsForPlayUI.length>0&&gameState.currentTableSuit){playConfirmText.textContent=`Play ${selectedCardsForPlayUI.length} card${selectedCardsForPlayUI.length > 1 ? 's' : ''} as ${SUIT_SYMBOLS[gameState.currentTableSuit]}?`;playConfirmArea.style.display='block';}else playConfirmArea.style.display='none';}
        function enableHandCardSelectionForPlay(enable){const hCs=playerHandArea.querySelectorAll('.card-container');if(enable){selectedCardsForPlayUI=[];playerHandArea.classList.add('card-selection-active');playerHandArea.classList.remove('current-player-hand'); hCs.forEach(c=>{c.classList.remove('selected-for-play');c.addEventListener('click',handleHandCardClickForPlay);});playCardsBtn.disabled=true;callLiarBtn.disabled=true;updatePlayConfirmArea();}else{playerHandArea.classList.remove('card-selection-active');if(gameState.currentPlayerId === localPlayer.id && !localPlayer.eliminated) playerHandArea.classList.add('current-player-hand');hCs.forEach(c=>{c.classList.remove('selected-for-play');c.removeEventListener('click',handleHandCardClickForPlay);});playConfirmArea.style.display='none';selectedCardsForPlayUI=[];updateActionButtons();}}
        
        function init() { 
            createRoomBtn.onclick=()=>{
                localPlayer.name=playerNameInput.value.trim();
                if(localPlayer.name.length<3){alert("Name must be at least 3 characters long.");return;}
                localPlayer.isHost=true;
                updatePlayerNameDisplay();
                hostControlsDiv.style.display='block';
                clientControlsDiv.style.display='none';
                roomCodeDisplay.textContent = 'Connecting to PeerServer...';
                clientStatusP.textContent = ""; 
                initializePeerJSHost();
                logDebug(`Host ${localPlayer.name} creating room...`);
            }; 
            
            joinRoomBtn.onclick=()=>{
                localPlayer.name=playerNameInput.value.trim();
                if(localPlayer.name.length<3){alert("Name must be at least 3 characters long.");return;}
                localPlayer.isHost=false;
                updatePlayerNameDisplay();
                hostControlsDiv.style.display='none';
                clientControlsDiv.style.display='block';
                clientStatusP.textContent = "Enter the Host's Room Code and click 'Connect to Host'.";
                clientStatusP.style.color = "var(--secondary-text)";
                roomCodeInput.focus();
            }; 

            connectToHostBtn.onclick=()=>{
                if(localPlayer.name.length<3){ 
                    alert("Please ensure your name is entered (Min 3 chars).");
                    playerNameInput.focus();
                    return;
                }
                const hostIdToJoin = roomCodeInput.value.trim();
                if(!hostIdToJoin){alert("Please enter the Host's Room Code."); roomCodeInput.focus(); return;}

                clientStatusP.textContent = `Attempting to connect to host: ${hostIdToJoin}...`;
                clientStatusP.style.color = "var(--accent-highlight)";
                connectToPeerJSClient(hostIdToJoin);
                logDebug(`Player ${localPlayer.name} attempting to join room: ${hostIdToJoin}`);
            };
            
            if (copyRoomCodeBtn) {
                copyRoomCodeBtn.onclick = () => {
                    const roomCode = roomCodeDisplay.textContent;
                    if (roomCode && !roomCode.startsWith("Waiting") && !roomCode.startsWith("Connecting") && !roomCode.startsWith("Error")) {
                        copyToClipboard(roomCode, copyRoomCodeBtn); 
                    } else {
                        alert("Room Code not available yet.");
                    }
                };
            }
            
            startGameBtn.onclick=()=>{
                if(localPlayer.isHost){
                    const connectedPlayerCount = Object.values(hostConnections).filter(conn => conn?.open).length + 1; 
                    if(connectedPlayerCount < MIN_PLAYERS){
                        alert(`Need at least ${MIN_PLAYERS} players to start. Currently have ${connectedPlayerCount}.`);
                        return;
                    }
                    logDebug("Host starting game (standard deck)...");
                    addLogMessage("Game starting!", "success");
                    initializeNewGame(); 
                    showGameBoard();
                }
            }; 

            playCardsBtn.onclick=()=>{enableHandCardSelectionForPlay(true);}; 
            confirmPlayBtn.onclick=()=>{if(selectedCardsForPlayUI.length>0&&selectedCardsForPlayUI.length<=3){const cIds=selectedCardsForPlayUI.map(c=>c.id);if(localPlayer.isHost)handleHostPlayerPlayCards(localPlayer.id,cIds);else sendMessage('PLAYER_ACTION_PLAY_CARDS',{cards:cIds});enableHandCardSelectionForPlay(false);}else alert("Please select 1 to 3 cards to play.");}; 
            cancelPlayBtn.onclick=()=>{enableHandCardSelectionForPlay(false);}; 
            callLiarBtn.onclick=()=>{if(confirm("Are you sure you want to call LIAR!? This cannot be undone.")){if(localPlayer.isHost)handleHostPlayerCallLiar(localPlayer.id);else sendMessage('PLAYER_ACTION_CALL_LIAR',{});}}; 
            continueGameBtn.onclick=()=>{toggleModal(challengeRouletteOverlay,false);if(gameState.gamePhase==='game_over')toggleModal(gameOverOverlay,true);}; 
            
            playAgainBtn.onclick = () => {
                if (gameState.gamePhase !== 'game_over') return;
                localPlayer.readyForRematch = !localPlayer.readyForRematch;
                playAgainBtn.textContent = localPlayer.readyForRematch ? "Waiting for Others..." : "Ready for Rematch";
                playAgainBtn.style.backgroundColor = localPlayer.readyForRematch ? 'var(--accent-green)' : 'var(--accent-gold)';

                if (localPlayer.isHost) {
                    gameState.rematchReadyStatus[localPlayer.id] = localPlayer.readyForRematch;
                    updateRematchStatusDisplay(); 

                    const eligiblePlayers = getConnectedAndActivePlayerIds();
                    const allActuallyReady = eligiblePlayers.length > 0 &&
                                             eligiblePlayers.every(id => gameState.rematchReadyStatus[id] === true);

                    if (eligiblePlayers.length >= MIN_PLAYERS && allActuallyReady) {
                        addLogMessage("All players ready! Starting rematch...", "success");
                        initializeNewGame(); 
                    } else {
                        broadcastGameState();
                    }
                } else { 
                    sendMessage('PLAYER_TOGGLE_REMATCH_READY', { isReady: localPlayer.readyForRematch });
                }
            }; 

            exitGameBtn.onclick=()=>{
                if(localPlayer.isHost && Object.keys(hostConnections).length > 0) {
                    sendMessage('HOST_DISCONNECTED',{message:"Host ended game and exited."});
                }
                addLogMessage("Exiting game to setup screen.", "system");
                showConnectionSetup(); 
            }; 

            document.addEventListener('keydown',e=>{const modalVis=Array.from(document.querySelectorAll('.modal')).some(m=>m.classList.contains('visible'));const inputFoc=['INPUT','TEXTAREA'].includes(document.activeElement.tagName);if(modalVis||inputFoc||connectionSetupDiv.style.display!=='none')return;if(e.key.toUpperCase()==='P'&&!playCardsBtn.disabled&&playConfirmArea.style.display==='none'){e.preventDefault();playCardsBtn.click();}if(e.key.toUpperCase()==='L'&&!callLiarBtn.disabled&&playConfirmArea.style.display==='none'){e.preventDefault();callLiarBtn.click();}}); 
            
            const debouncedRender = debounce(updateFullUI, 250);
            window.addEventListener('resize', debouncedRender);
            
            window.addEventListener('beforeunload',()=>{
                if(localPlayer.isHost && gameState.gamePhase!=='lobby' && Object.keys(hostConnections).length > 0){
                    sendMessage('HOST_DISCONNECTED',{message:"Host has left the page."});
                }
                if (localPlayer.peer && !localPlayer.peer.destroyed) { 
                    localPlayer.peer.destroy();
                }
            }); 
            showConnectionSetup(); 
            logDebug("E-Money's Bar initialized with PeerJS.");
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>